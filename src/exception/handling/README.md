# 예외 처리 방식 세 가지
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Exception-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Handling-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 예외 복구
`예외 복구`는 **에외가 발생하더라도 해당 로직에서 애플리케이션이 정상 작동하도록 처리하는 방식**을 뜻한다.  
예외가 발생하면 **일정 시간과 횟수 기준을 정해 재실행하거나 다른 작업 흐름으로 자연스럽게 유도**하는 두 가지  
방식을 주로 사용한다. 보통 서버 상태가 불안정하거나 다수의 클라이언트 요청으로 순번이 밀려나 정상적인  
응답을 받지 못하는 상황에 해당 복구 방식을 사용한다.  

<img width="626" alt="case1" src="https://user-images.githubusercontent.com/78818063/171060514-d234294c-6fc3-46fd-86c1-dbb106e97a94.png">

만약 멀티 스레드 방식의 `WAS(Web Application Server)`에서 다수의 클라이언트 요청으로 인해 모든  
스레드가 작업을 진행하고 있어 내 요청에 대한 스레드 할당이 대기 상태인 경우를 생각해보자. 위 코드처럼  
대기 시간과 재시도 횟수를 지정해 재요청을 보내고, 해당 기준을 초과했을 때 현재 상태를 해결할 새로운  
비즈니스 로직을 수행할 수 있다. 즉 특정 로직에서 **예외가 발생하였더라도 해당 로직을 재수행하여 다시  
정상적으로 복구할 수 있으며**, 다른 **예외 처리 로직이나 새로운 예외로 흐름을 전환**하여 사용자로 하여금  
애플리케이션이 정상적으로 작동하는 것처럼 느끼게 할 수 있다.  

<br>

## 2. 예외 회피
`예외 회피`는 해당 로직에서 예외 처리를 직접하지 않고, **예외를 메소드나 생성자를 호출한 쪽으로 던져 회피하는  
방식**을 뜻한다. 키워드 `throws`와 예외를 명시하면 메소드를 호출할 때 해당 예외에 대한 처리 구문을 작성해야 한다.  
주로 어떤 예외가 발생할지 예측 가능한 경우에 회피 방식을 사용한다. 호출 시 선언부를 보고 어떤 예외들이 처리되어야  
할지 가시적으로 나타낼 수 있으며 외부에서 Caller(호출자)의 **요구 사항에 따라 적절하게 예외를 처리**할 수 있다.

<img width="626" alt="case2" src="https://user-images.githubusercontent.com/78818063/171060492-0ee210a0-3136-41c8-a74e-d7355df3c587.png">

위 코드는 예외 회피 방식을 이메일 찾기 기능에 적용하고 있다. 만약 특정 이메일을 찾지 못하였고, 해당 예외를  
내부에서 이미 처리하여 "email has not found"라는 문자열을 반환한다고 가정해보자. Caller는 해당 문자열을  
외부에서 다시 비즈니스 로직에 알맞게 바꿔주고 싶다. 상황에 따라 체이닝 메소드로 사용되어 0, 1과 같은 특정  
값을 반환해야 하거나 그대로 응답 메세지로 전송할 수도 있을 것이다. 즉 개발자들이 처리하고자 하는 **작업 방식이  
각각 다를 수 있어, Caller로 하여금 직접 예외를 처리하는 것이 현명하다 판단될 때 책임을 분리하기 위해 사용**된다.   

<br>

## 1. 예외 전환
`에외 회피`와 비슷한 예외 전환은 Caller에게 발생한 예외를 그대로 넘기는게 아닌 **적절한 예외로 전환해서 던지는  
방식**을 뜻한다. 이 방식을 사용하는 목적은 두 가지인데, 첫 번째로 **내부에서 발생한 예외가 추상적인 경우 예외 상황에  
대한 적절한 의미를 분명히 전달**하기 위해 예외를 구체화 한, 즉 하위에 있는 클래스로 전환하여 던진다. 두 번째는 **내부에서  
발생한 예외를 포장하여 쉽고 단순하게 처리**하기 위해 사용한다. 이는 의미를 명확히 하기 위한 방식이 아닌 예외 처리를  
강제하는 체크 예외(Checked Exception)를 언체크 예외(Unchecked Exception), **런타임 예외로 바꾸어 Caller에서  
별도의 예외 처리를 명시하지 않아도 되도록 한다**. 즉 무분별한 **예외 사용을 막고, 처리 로직을 실행하며, 예외를 전환하여  
불필요한 작업을 생략**하는 것이다. 

<img width="626" alt="case3" src="https://user-images.githubusercontent.com/78818063/171060498-f8e5eccf-5c3d-40ff-94eb-2875fdb28278.png">

위 코드의 JDBC는 중복되는 아이디를 발견했을 때 SQLException을 발생시키는데, 다음과 같이 전환할 예외에 원래 발생한  
예외를 담아서 중접 예외(Nested Exception)로 만들어 준다. 그리고 명확한 의미를 알 수 하위에 있는 DuplicatedUserException  
예외로 바꿔서 던져 줄 수 있다. 이때 getErrorCode() 메소드를 사용해 해당 예외가 무엇인지 명확하게 알 수 있다. 또한 해당  
예외는 **언체크 예외이므로 다른 계층에서 별도의 예외를 선언할 필요가 없어진다**. 

<br>
