# 예외 처리 방식 세 가지
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Exception-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Handling-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 예외 복구
`예외 복구`는 **에외가 발생하더라도 애플리케이션이 정상 작동하도록 처리하는 방법**을 의미한다. 예외가 발생하면 **일정 시간과 횟수 기준을 
정해 재실행하거나 다른 작업 흐름으로 자연스럽게 유도**하는 두 가지 방식을 주로 사용한다. 보통 서버의 상태가 불안정하거나 다수의 클라이언트 
요청으로 순번이 밀려나 정상적인 응답을 받지 못하는 상황 등에 복구 방식을 사용한다. 

<img width="626" alt="case1" src="https://user-images.githubusercontent.com/78818063/171060514-d234294c-6fc3-46fd-86c1-dbb106e97a94.png">

예를 들어 멀티 스레드 기반 `WAS(Web Application Server)`에서 트래픽이 급증해 스레드 할당이 불가능한 예외가 발생했다고 가정해보자. 
보통은 예외가 발생한 로직을 벗어나 클라이언트에게 처리 결과를 전달할 것이다. 하지만 복구 방식은 대기 시간이나 재시도 횟수를 지정해 할당이 가능할 
때까지 재요청을 보내도록 한다(응답 대기 상태). 이는 특정 로직에서 **예외가 발생하면 곧 바로 해당 구문을 벗어나지 않고 정상적으로 작업이 완료될 때까지 
로직을 재수행하**여 사용자 입장에서 **애플리케이션이 정상 작동하는 것처럼 느끼게 만든다**. 또한 다른 **예외 처리 로직이나 다른 예외로 흐름을 전환**해 
특정 비즈니스 로직을 실행시킬 수도 있다.

<br>

## 2. 예외 회피
`예외 회피`는 로직에서 예외 처리를 직접하지 않고, **예외가 포함된 구문을 호출한 쪽으로 던져 회피하는 방법**을 의미한다. 키워드 `throws`와 예외를 구문을 
작성하면 메소드를 호출할 때 해당 예외에 대한 처리 구문을 작성해야 한다. 주로 어떤 예외가 발생할지 예측 가능한 경우에 회피 방식을 사용하며, 호출 시 선언부를 보고 
어떤 예외들이 처리되어야 할지 가시적으로 나타낼 수 있어 외부에서 Caller(호출자)의 **요구 사항에 따라 적절하게 예외를 처리**할 수 있다.

<img width="626" alt="case2" src="https://user-images.githubusercontent.com/78818063/171060492-0ee210a0-3136-41c8-a74e-d7355df3c587.png">

위 코드는 예외 회피 방식을 이메일 찾기 기능에 적용시킨 예시로, 만약 특정 이메일을 찾지 못했다면 내부에서 예외를 처리해 "email has not found"라는 
문자열을 반환한다고 가정해보자. Caller는 오류 메시지를 특정 비즈니스 로직에 따라 알맞게 바꿔주고 싶다. 상황에 따라 체이닝 방식을 사용해 0, 1과 같은 특정 
값을 반환하거나 그대로 응답 메세지로 전송할 수도 있을 것이다. 즉 개발자들이 처리하고자 하는 **작업 방식이 각각 다를 수 있어, Caller로 하여금 예외를 직접 
처리하는 것이 현명하다 판단될 때 책임을 분리시키기 위해 사용**된다.

<br>

## 3. 예외 전환
`에외 회피`와 비슷한 예외 전환은 의미 그대로 Caller에게 기존 예외를 그대로 넘기지 않고 **적절한 예외로 전환해서 던지는 방식**을 의미한다. 
이 방식을 사용하는 목적은 두 가지로, 첫 번째는 **내부에서 발생한 예외가 추상적이라 예외 상황에 따른 의미를 분명히 전달**하기 위해 사용된다. 
보통 상위 클래스의 예외를 보다 구체적인 하위 클래스로 전환하기 위함이다. 두 번째는 **내부에서 발생한 예외를 포장하여 쉽게 처리**하기 위해 사용된다. 
이는 의미를 명확히 하기 위한 방식이 아닌 예외 처리를 강제하는 체크 예외(Checked Exception)를 언체크 예외(Unchecked Exception), 즉 **런타임 
예외로 바꿔 Caller가 별도의 예외 처리를 명시하지 않아도 되도록 한다**. 즉 예외가 발생하더라도 **별도의 처리 구문을 작성하지 않아도 되기 떄문에 
불필요한 작업을 생략**하는 것이다. 

<img width="626" alt="case3" src="https://user-images.githubusercontent.com/78818063/171060498-f8e5eccf-5c3d-40ff-94eb-2875fdb28278.png">

JDBC는 중복되는 아이디를 발견했을 때 `SQLException` 예외를 발생시킨다. 이때 기존 발생한 예외에 새로운 예외를 담은 중첩 예외(Nested Exception)를 
만들어 예외를 회피하는데, 여기서 **한 가지 주목할 점은 Caller는 전환된 예외의 처리 책임을 넘겨받는다는 것**이다. 즉 하위에 있는 `DuplicatedUserException` 
예외를 처리해야 하는데, 해당 예외는 **언체크 예외로 별도의 예외를 선언할 필요가 없다**. 또한 **의미가 보다 분명해져** 예외가 발생했을 때 어떤 문제가 
발생했는지 파악하기도 쉽다.

<br>
