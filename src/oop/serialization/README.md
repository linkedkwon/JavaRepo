# 데이터를 외부로, 직렬화(Serialization)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Serialization-yellow" style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 직렬화란?
`직렬화`란 프로그래밍에서 **사용하는 구조체 또는 객체 상태의 데이터를 다른 물리적 환경에서 저장하고 재구성할 수 있는 포맷으로 
변환하는 과정**을 의미한다. 물리적으로 메모리 상 여러 곳에 분포된 데이터들을 모아 플랫폼에 독립적인(Platform Independent) 
**일련의 바이트 스트림**을 만들기 때문에 복잡한 데이터 집합을 네트워크를 통해 **외부로 전송하거나 파일로 저장 가능**하다. 반대로 
직렬화 된 바이트 스트림으로부터 데이터 구조를 추출하는 과정을 `역직렬화(Deserialization)`라 부르며, 저장된 데이터 집합을 
필요할 때 다시 재구성하여 사용할 수 있다.

![serialization](https://user-images.githubusercontent.com/78818063/175867163-142bc6b5-9ac2-4dcc-beb9-f40c7624be60.png)

<br>

## 2. Java의 직렬화
Java의 직렬화 기능은 `Serializable` 인터페이스를 통해 제공하는데, 시스템 내부에서 생성한 **객체를 입출력 시 자동으로 
바이트 단위로 변환**하여 외부에서도 사용할 수 있게 한다. 이는 JVM(Java Virtual Machine)의 메모리 영역에 할당되어 있는 
인스턴스를 가르키며, 변환된 **바이트 스트림을 외부로 전송**한다. 그리고 해당 데이터를 받은 외부 시스템은 `언마샬링(Unmarshalling 
<-> 마샬링)` 또는 `역직렬화`를 통해 데이터를 다시 **원상태로 복구**한다. 

![onJava](https://user-images.githubusercontent.com/78818063/175867176-24978285-37ac-4fde-a7c5-08e8eef08888.png)
  
<br>

## 3. 사용하는 이유
앞서 직렬화의 정의와 함께 기본적인 동작 원리에 대해 살펴보았다. 그렇다면 이러한 직렬화 기능이 Java에서 사용되는 이유가 무엇인지 
아래에 항목들에서 알아보자.

  * ### 데이터 형식 ###
    일반적으로 프로그래밍에서 사용하는 **데이터 타입은 크게 기본형과 참조형 두 가지**로 나눌 수 있다. 이 중 **저장과 전송이 
    가능한 데이터는 기본형 데이터**인데, 참조형 데이터는 해당 인스턴스의 주소 값을 가지고 있기 때문에 파일 저장이나 네트워크 
    전송이 불가능하다. 만약 주소 값 자체를 강제로 외부에 보낸다 하더라도 해당 값은 이해할 수 없는 무의미한 문자열 덩어리일 뿐이다.

  * ### 직렬화 처리 과정 ###
    이처럼 참조형 데이터는 객체가 가지고 있는 **주소 값이 아닌 실제 인스턴스의 정보를 가져와야 한다**. 즉 실제 인스턴스에 포함된 내용을 
    **Primitive한 값 형식 데이터로 변환하는 작업을 직렬화 과정**이라 말할 수 있다. 이렇게 직렬화 과정을 거치고 나면 데이터는 언어에 
    따라 **텍스트나 바이너리 등의 모양을 띄우기 때문에 외부에서 파일로 저장하거나 송신받아 파싱할 수 있는 유의미한 데이터**가 된다. 정리하자면 
    참조형 데이터를 전송 및 저장이 가능하도록 만드는 행위를 직렬화라고 부르며, 패킷 전송 시 파싱할 수 있는 데이터를 만들기 위해 사용된다. 
    
  * ### 실제 활용 ###
    직렬화는 서로 다른 물리적 환경에 있는 경우 뿐만 아니라 프로세스 간 데이터 전송에도 사용된다. 이러한 이유는 대부분의 OS가 가상 메모리를 
    운영 중이기 떄문인데, 대부분 프로세스 구현은 서로 다른 `가상 메모리 주소 공간(VAS, Virtual Address Space)`를 갖는다. 이는 앞서 살펴본 
    Java의 참조형 데이터와 마찬가지로 주소값을 담고 있기 때문에 직렬화를 통해 실제 데이터 교환을 진행한다. 이외에도 **서블릿에서 세션을 관리하거나 
    엔티티를 캐싱하는 등 실제 메모리에 상주하고 있는 데이터를 외부 파일 등으로** `영속화(Persistence)` **시킬 때 자주 사용**된다. 
    
  * ### 이점 ###
    Java의 직렬화는 CSV나 JSON 등의 다른 방식과는 다르게 **내부에서 설계한 객체 데이터를 그대로 영속화 하기 위해 사용**된다. 이는 
    직렬화 기능이 **Java 시스템 개발에 최적화**되어 있기 때문인데, 복잡한 데이터 구조의 객체라도 **조건만 지킨다면 쉽게 직렬화가 가능**하다. 
    또한 **데이터 타입이 자동으로 맞춰지므로** 해당 부분을 신경 쓰지 않아도 된다. 

<br>

## 4. 사용법
직렬화 기능을 사용하는 법은 매우 간단하다. 아래 항목을 순서대로 살펴보자.

  * ### 조건 ###
    먼저 직렬화 할 객체는 아래와 같이 **Serialize 인터페이스를 상속받아야 한다**. 이때 전송하기 민감한 데이터가 있다면 멤버 변수에 
    `transient`라는 키워드를 정의해 **제외시킬 수 있다**. 

    ![condition](https://user-images.githubusercontent.com/78818063/175867182-7040df18-3cff-4486-b358-eb08a6fac05d.png)

  * ### 입출력 스트림 ###
    해당 인터페이스를 상속 받으면 **객체의 직렬화가 자동**으로 일어나며, 직렬화가 된 클래스의 객체를 쓰고 읽는 **입출력 스트림을 통해 외부로 
    변환된 바이트 패킷을 전송**한다. 또한 외부로부터 데이터를 받아 다시 **객체로 재구성하는 역직렬화 역시 가능**한데, 읽은 객체는 Object 타입으로 
    반환받기 때문에 **적절한 클래스 타입으로 형변환 해야 한다**. 아래는 각 예시를 나타내는 코드들이다.

    ![serialAndDeserial](https://user-images.githubusercontent.com/78818063/175867186-6b93c310-fda6-4f94-9b39-77fe127b53ef.png)

  * ### 주의할 점 - 직렬화 버전 관리(SUID, SerialVersionUID) ###
    객체의 직렬화와 역직렬화에서 주의할 점은 해당 객체와 외부 시스템은 **동일한 클래스 구성을 매개체로 하여 데이터를 송수신** 해야 한다는 점이다. 
    이는 **객체의 멤버 변수들이 모두 같아야 함**을 의미하는데, 각 시스템에서 사용하고 있는 모델의 버전 차이가 발생했을 경우 `java.io.InvalidClassException` 
    예외가 발생한다.

    ![uid](https://user-images.githubusercontent.com/78818063/175867192-7715b1ce-129e-43f0-ac1c-76b31d490e44.png)

    이처럼 InvalidClassException 발생을 예방하기 위해서는 **객체의 버전 관리가 필요하다**. 직렬화 기능을 적용할 클래스 내부에는 
    `SUID(SerialVersionUID)` **속성을 두고 해당 클래스의 버전을 기억해 로드 된 클래스와 직렬화 된 객체가 호환되는지 확인**할 수 있다. 
    기본적으로 해당 UID 값을 런타임 시 클래스의 기본 해쉬 값을 통해 자동 할당하지만 환경에 따라 **컴파일러 구현에 따라 각기 다른 값을 
    가질 수 있으므로 값을 명시적으로 선언하는 것이 좋다**. 선언 방법은 **private 접근 제어자와 static, final과 함께 long 타입의 
    serialVersionUID 필드를 선언해 특정 값으로 초기화**하면 된다.
    
<br>

