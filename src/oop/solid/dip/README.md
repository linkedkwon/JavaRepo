# 의존 역전 원칙(DIP, Dependency Inversion Principle)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/SOLID-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DIP-blue"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 의존 역전 원칙이란?
`의존 역전 원칙`은 **저수준 모듈이 아닌 고수준 모듈에 의존해야 하는 것을 의미**한다. 여기서 말하는 저수준 모듈이란 구현 객체를, 고수준 모듈은 추상 클래스나 
인터페이스와 같은 추상 자료형을 뜻한다. 즉 **의존성을 주입받을 떄 대상 객체를 외부에서 바로 인스턴스화하여 받는 것이 아니라 인터페이스나 추상 클래스와 같은 추상 
자료형과 관계를 맺도록 하여, 하위 레벨의 모듈이 상위 레벨 모듈의 변경을 요구하는 구조적 문제 발생을 방지**시키는 방식이다. 즉 객체 사이 의존성을 주입할 `추상적 
계층`을 만들고, 이를 매개체로 하여 객체 간 의존 관계를 형성시킨다. 이같은 원칙을 적용하면 객체 간 **의존 관계를 보다 느슨하게** 만들 수 있어 더욱 효율적으로 
시스템을 제어할 수 있다.

![dip](https://user-images.githubusercontent.com/78818063/177644904-f4719f2c-9d8f-4e11-9634-cb4f18715f34.png)

* **고수준 모듈** : 추상 클래스나 인터페이스와 같은 추상 자료형
* **저수준 모듈** : 구현 객체

<br>

## 2. 사용하는 이유
앞서 의존 역전 원칙의 정의에 대해 알아 보았는데, 보다 자세한 이해를 위해 아래에서 해당 원칙이 적용된 코드와 그렇지 않은 코드를 
비교해보자.

  * ### 적용되지 않은 경우 ###
    먼저 원칙이 적용되지 않은 예시로, PayService 클래스는 A, B, C의 세 가지 업체의 결제 시스템을 통해 업무를 수행한다.

    ![case1](https://user-images.githubusercontent.com/78818063/177661561-800037f8-576c-4113-950c-bb18da958684.png)

    내부에는 세 업체의 시스템을 나타내는 참조 변수들, 각 시스템의 인스턴스를 할당할 세터, 결제 로직을 수행할 executePay() 메소드로 구성되어 있다. 
    executePay() 메소드는 인자로 업체의 고유값을 받아 사용할 결제 시스템을 선택하여 인스턴스를 할당한다. 별다른 문제가 없어보이지만 현재 PayService 
    클래스는 **세 업체 클래스에 의존하고 있으며, 개방 폐쇄 원칙이 전혀 적용되지 않고 있다**. 만약 새로운 업체가 추가된다면 새로운 참조 변수와 세터도 함께 
    추가될 것이며, executePay() 메소드의 내부 로직 또한 변경될 것이다. 이렇게 **한 가지 기능이 수정될 때 다른 코드가 동시에 영향을 받는 상황**은 개발, 
    확장, 유지보수 등 거의 대부분의 작업에서 비효율적이고 높은 비용이 책정될 것이다.

  * ### 적용된 경우 ###
    다음은 원칙이 적용된 예시로, 세 업체의 시스템을 `추상화한 PayModule 인터페이스`가 추가되었다.

    ![case2](https://user-images.githubusercontent.com/78818063/177661567-a8ae0179-cf70-4e0f-a472-845a382e166f.png)

    기존 PayService 클래스는 세 업체 클래스에 의존하고 있었지만, 이제는 **보다 고수준의 PayModule 인터페이스에 의존하고 있다. 즉 의존했던 상황이 역전되어 
    저수준 모듈이 고수준 모듈에 의존하게 된 것이다**. 세 업체는 새로운 모듈로서 재탄생하게 되었고, 이제 **오직 PayModule 타입만으로 모든 업체의 시스템이 조작 가능**하다. 
    또한 각 업체는 추상화된 기능을 상속받아 세부 작업을 다르게 처리할 수 있다. 의존 역전 원칙을 적용시켜 객체 관계 구조는 보다 유연해졌고 확장과 재사용에 더욱 특화되었다.

<br>

결론적으로 의존 역전 원칙이란 **객체에 의존성을 주입할 때 보다 추상적인 고수준 모듈에 의존하도록 하는 방식**을 의미한다. 이는 다른 SOLID 원칙과 밀접한 관련이 
있는데, 객체가 오직 하나의 관심사를 다루는 `단일 책임 원칙`이나 클라이언트가 사용하지 않는 기능의 의존성을 제거하는 `인터페이스 분리 법칙`을 적용시키면 자연스레 
해당 원칙이 준수되기 때문이다. 즉 여러 원칙이 복합적으로 잘 적용된 시스템은 `복잡한 컴포넌트 관계를 단순화`할 수 있고 원활한 커뮤니케이션 수단을 제시해 보다 `쉽게 
객체나 모듈의 제어`가 가능하다. 또한 향후 수정과 유지보수 작업에서 앞서 제시한 추상 모듈의 수정만 진행하면 되므로 코드는 `높은 재사용성과 확장성`을 갖출 수 있다.
보통 프레임워크에서는 이같은 원칙들이 적용된 객체를 컨테이너에서 관리하는 `제어의 역전(IoC, Inversion of Control)` 기능을 제공하여 개발자로 하여금 
**비즈니스 로직에만 집중**할 수 있도록 편의를 제공하기도 한다.

<br>
