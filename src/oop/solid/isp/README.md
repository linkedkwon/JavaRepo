# 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/SOLID-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/ISP-blue"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 인터페이스 분리 원칙이란?
`인터페이스`란 공통으로 사용되는 기능과 상수를 추상화하고, 이를 특성에 맞게 재정의하여 객체들의 다형성을 제공하는 추상 자료형이다. 
이를 상속받은 클래스는 반드시 해당 기능들을 재정의해야 하기 때문에 기본 골격을 제시하는 설계도라 불리기도 하지만, **모든 메소드를 
재정의함으로서 잘못된 설계는 불필요한 메소드를 하위 객체에 모두 포함시키는 문제를 발생**시킨다. 따라서 인터페이스를 보다 효율적으로 
설계하기 위해 등장한 원칙이 바로 `인터페이스 분리 원칙`이다. 이는 **클라이언트가 자신이 이용하지 않는 메소드에 의존하지 않도록 하며, 
가능한 최소한의 인터페이스만 정의하여 클래스나 모듈에 특화되도록 기능을 분리시키는 방식**을 의미한다.

![isp](https://user-images.githubusercontent.com/78818063/177428625-13395c9c-e833-4419-82cf-b3d0023f114c.png)

<br>

## 2. 사용하는 이유
앞서 인터페이스 분리 원칙의 정의에 대해 알아 보았는데, 보다 자세한 이해를 위해 아래에서 해당 원칙이 적용된 코드와 그렇지 않은 코드를 
비교해보자.

  * ### 적용되지 않은 경우 ###
    먼저 원칙이 적용되지 않은 예시로, 아래 코드는 이동 수단과 관련된 모든 기능을 하나의 인터페이스에서 추상화하여 관리하고 있다. 

    ![case1](https://user-images.githubusercontent.com/78818063/177480602-78d60b06-b669-404f-be9b-843bc4685997.png)

    Vehicle 인터페이스 내부에는 비행, 노 젓기, 짐 싣기의 세 가지 기능을 포함하고 있으며, 이를 Airplane, Boat, Ship의 세 가지 클래스가 
    상속받아 각 기능을 재정의하고 있다. 인터페이스 설계 관점에서 봤을 때는 Vehicle 인터페이스는 자신의 특성과 관련된 모든 기능을 추상화하고, 이를 
    군집화했다고 볼 수 있다. 하지만 **혼자 너무 많은 책임을 가지고 있고**, **하위 클래스의 관점에서는 전혀 관계 없는 기능을 재정의해야 하므로 오히려 
    응집도가 떨어졌고** **Vehicle 인터페이스에 대한 의존성이 높아지게 되었다**. 또한 **내부 코드 더미로 인해 기존 설계 의도를 파악하기 힘들어 
    졌으며, 기능의 결합도 또한 높아져 수정이나 유지보수와 같은 작업에 매우 불리해졌다**.

  * ### 적용된 경우 ###
    그렇다면 분리 원칙이 적용된 예시를 살펴보자. 아래는 이전 단일 인터페이스 Vehicle을 **클라이언트 관점에서 해석**하여 분리하고 있다. 

    ![case2](https://user-images.githubusercontent.com/78818063/177480605-b77c8dc0-094d-423c-a692-6a69bd42401d.png)

    위 코드는 **클라이언트의 요구 사항에 따라** 한 곳에서 관리하던 기능들을 각각 Fly, Paddle, Load 인터페이스로 새롭게 정의하여 
    하위 객체들이 자신과 관련없는 메소드에 의존하지 않도록 수정하였다. 즉 **사용하지 않는 인터페이스에는 영향을 받지 않고 기능에 대한 
    의존성을 고려할 필요도 없어졌다**. 이로서 **객체 구조는 의존성과 결합도가 현저히 낮아졌으며**, 특정 기능에 대한 수행, 수정, 확장 등의 
    모든 작업에서 사용되던 비용을 절감할 수 있게 되었다.

<br>

결론적으로 인터페이스 분리 원칙은 여러 기능을 한 곳에 두지 않고, 클라이언트의 **요구 사항에 따라 인터페이스를 각각 분리시켜 필요한 객체에서만 
상속받도록 한다**. 분리된 인터페이스는 시스템의 `내부 의존성을 약화시켜 결합도를 낮추기 때문`에 **향후 유지 보수, 리팩토링, 개별적인 수정 및 배포** 
등의 여러 작업에서 높은 효율을 낼 수 있다. 또한 이를 상속받은 하위 객체들은 `자신의 관심사에 따른 기능만을 보유`하므로 보다 **높은 응집력을 가질 수 
있어, 더욱 명확히 설계 의도**를 드러낼 수 있다. 즉 개발자는 이처럼 객체 관계를 설계할 때 인터페이스를 기능별로 잘 그룹화하여 분리시켜야 하며, 또한 기능별로 
추상화하여 잘 묶을 수 있게 거듭 고민하고 훈련하는 작업이 필요하다.

<br>
