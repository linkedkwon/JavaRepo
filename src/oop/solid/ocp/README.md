# 개방 폐쇄 원칙(OCP, Open Closed Principle)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/SOLID-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OCP-blue"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 개방 폐쇄 원칙이란?
`개방 폐쇄 원칙`은 소프트웨어 구성 요소들(클래스, 모듈, 메소드 등)이 **확장에는 열려 있고, 수정에는 닫혀 있도록** 하는 설계 방식을 의미한다. 
이 원칙의 핵심은 **기존 코드를 변경하지 않고 기능을 수정하거나 확장할 수 있도록 하는 것**으로 아래 두 가지 원칙이 적용되어야 한다.

* **확장에 열려 있다** : 자신의 기능을 추가하거나 확장시킬 수 있다.
* **변경에 닫혀 있다** : 확장일 일어났을 때 상위 레벨(호출자)의 코드가 변경되지 않는다.

이같은 원칙을 적용하면 특정 기능을 담당하는 모듈을 따로 관리할 수 있어 **시스템에 유연성**을 갖출 수 있다. 객체들을 관심사에 따라 적절히 
구조화하여 **정보를 캡슐화**할 수 있으며, 객체 사이 **의존성을 최소화**하여 수정과 유지보수에 있어 영향력을 최소화시킨다. 주로 `인터페이스`를 
통해 기능을 추상화하고 분리시킨다.  

![ocp](https://user-images.githubusercontent.com/78818063/177137053-b2b72cbd-1065-4887-adb4-ec582b97de9f.png)

## 2. 사용하는 이유
앞서 개방 폐쇄 원칙의 정의에 대해 알아보았는데, 해당 원칙이 의미하는 바를 보다 자세히 이해하기 위해 원칙이 적용된 코드와 그렇지 않은 코드 
두 가지를 비교해보자.

  * ### 적용되지 않은 경우 ###
    먼저 원칙이 적용되지 않은 예시부터 살펴보자. 결제와 관련된 비즈니스 로직을 수행하는 PayService는 현재 A업체의 결제 시스템을 통해 
    인증과 결제 작업을 수행하고 있다.

    ![case1](https://user-images.githubusercontent.com/78818063/177137061-035ab5cd-315f-42df-a4c6-66302f6aa6a9.png)
    
    이러던 중 **새로운 B업체의 결제 시스템**이 등장한다. B업체는 각종 혜택으로 높은 소비자 점유율을 지니고 있어 한시라도 빨리 해당 
    시스템을 **추가해야 한다**. 

    ![case2](https://user-images.githubusercontent.com/78818063/177138236-0d818048-0f1a-49fb-95e4-78bc8cffbaaf.png)

    새로운 B업체의 결제 시스템이 추가되었다. 기능이 확장됨에 따라 PayService는 **새로운 객체를 추가적으로 관리하게 되었고**, 결제 수행 
    **메소드에는 각 업체를 구분하는 코드들이 추가**되었다. 이는 개방 폐쇄 원칙이 적용되지 않은 문제로 확장에 해당되는 객체만 수정하는 것이 
    아닌, 이를 의존하는 executePay() 메소드와 같은 다른 로직들이 함께 수정되는 현상이 발생한다. 이렇게 **한 가지 기능이 수정될 때 
    다른 코드가 동시에 영향을 받게 된다면**, 이후 기능 확장에 매우 불리하게 작용될 것이며, 유지보수나 리팩토링 작업에서 높은 비용이 책정될 
    가능성이 크다.
    
  * ### 적용된 경우 ###
    그렇다면 위 예제에 개방 폐쇄 원칙을 적용시켜 다시 한 번 기능을 확장해보자.

    ![case3](https://user-images.githubusercontent.com/78818063/177137070-bd85c3c2-33ab-43e5-bea5-2dcb070eedb9.png)
    
    이전 에제를 자세히 보면 새로 추가된 B업체의 시스템은 기존 A업체의 시스템과 동일한 기능을 가지고 있으며, 결제 작업의 세부 과정만 
    조금 다른 것을 확인할 수 있다. **다시말해, 두 시스템의 공통 기능을 묶어, 이를 추상화하여 모듈로서 조작이 가능하다**. 따라서 결제 모듈을 
    관리하는 새로운 **Pay 인터페이스를 만들어 공통 기능을 추상화시키면, 각 업체는 이를 상속받아 세부 작업을 다르게 처리**할 수 있다.

    ![case4](https://user-images.githubusercontent.com/78818063/177137078-7bdd6070-16cd-4e0c-a386-7566937712ea.png)

    이러한 추상화 작업이 적용되면 결제 작업을 담당하는 PayService는 **각 업체의 객체를 앞서 만든 상위 클래스 Pay 타입으로 추상화하여 
    관리**할 수 있다. **선택 옵션에 따라 타입을 외부에서 `형변환(자세히는 Down Casting)`하여 주입받으면 결제를 수행하는 executePay() 
    메소드의 기존 코드는 변하지 않는다**. 즉 자신의 확장에는 열려 있고, 다른 변경에는 닫혀 있는 개방 폐쇄 원칙이 제대로 적용된 것이다. 
    마치 객체나 모듈을 부품 취급해 기능 수정과 추가 등 여러 상황에서 시스템이 유연성을 가지는 모습을 볼 수 있다.
    
<br>

일반적으로 개방 폐쇄 원칙이 적용되는 모듈은 **고정된 추상화에 의존하는 경향이 크다**. **수정에 대해 닫혀 있도록 함과 동시에 새로운 클래스를 만들어 
확장도 가능하게 한다**. 즉 추상화는 개방 폐쇄 원칙의 핵심 요소라 볼 수 있다. 즉 객체 지향 프로그래밍의 가장 큰 핵심 원칙으로 볼 수 있으며, 이가 잘 
적용된 시스템은 `유연성`, `재사용성`, `유지보수성` 등의 큰 이점을 가진다.

<br>
