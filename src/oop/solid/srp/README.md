# 단일 책임 원칙(SRP, Single Responsibility Principle)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/SOLID-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/SRP-blue"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 단일 책임 원칙이란?
`단일 책임 원칙`이란 **모든 클래스는 하나의 책임을 가지며, 이러한 책임을 완전히 캡슐화해야 함을 의미**한다. 여기서 말하는 
책임이란 클래스가 제공하는 기능을 의미하는데, 만약 하나의 클래스가 여러 가지 기능을 담당하게 된다면 **일부 기능을 수정하기 
위해 매번 클래스의 수정이 불가피해진다**. 따라서 **클래스를 변경하는 이유는 단 하나여야만 하고, 하나의 클래스는 오직 하나의 
액터(Actor)에 대해서만 책임**을 지도록 설계해야 한다.

![srp](https://user-images.githubusercontent.com/78818063/177000124-13e08d0d-c49e-4742-a361-e4165c85a240.png)

<br>

## 2. 사용하는 이유
앞서 단일 책임 원칙의 정의에 대해 알아보았는데, 해당 원칙이 의미하는 바를 보다 자세히 이해하기 위해 원칙이 적용된 코드와 
그렇지 않은 코드 두 가지를 비교해 보자.

  * ### 적용되지 않은 경우 ###
    먼저 클래스가 여러 책임을 가져 결합도가 높아진 설계 방식의 예시를 살펴보자.

    ![case1](https://user-images.githubusercontent.com/78818063/177000127-645e744a-268f-4e10-85a3-794836394419.png)
    
    현재 Member 클래스에는 회원의 속성(Property)과 데이터베이스 작업을 관리의 두 가지 책임을 포함하고 있다. 이처럼 하나의 클래스가 
    여러 가지 책임을 동시에 가지고 있을 때 **시스템 또는 서비스 내용에 따른 수정**이 일어나면 어떻게 될까? 기존 회원 데이터에 이름 컬럼을 
    추가해보자.

    ![case2](https://user-images.githubusercontent.com/78818063/177000128-d53e4df4-5926-432d-b8fd-f5299a655473.png)  

    위 코드는 속성이 추가됨에 따라 멤버 변수가 추가되었고 **데이터베이스 기능 또한 추가 속성을 처리하기 위해 코드가 수정되었다**. 
    이처럼 **결합도가 높은 클래스는 하나의 책임에 대한 변경이 다른 책임의 변경을 발생**시킬 수 있다. 만약 회원 속성이 추가되었을 
    떄 다른 수많은 기능들이 해당 속성을 사용해야 한다면, 클래스는 단지 필드 하나를 추가헀을 뿐이지만 대규모 수정 작업이 필요하다. 
    또한 수정이 일어난 클래스 파일은 모두 재컴파일 및 재배포와 같은 특정 작업들도 필요하다. 즉 **클래스는 책임이 많아질수록 다른 
    책임과의 의존 및 연관성이 늘어나게 되며, 수정에 따른 영향력과 추가적인 작업량 등이 매우 커질 수 밖에 없다.** 
    
  * ### 적용된 경우 ###
    다음은 위 예제에 단일 책임 원칙을 적용된 예시다.

    ![case3](https://user-images.githubusercontent.com/78818063/177000129-21ca2e9a-f8f5-401e-98e2-6a70abc90904.png)
    
    위 코드는 이전 항목에서 보았던 두 가지 책임을 프로퍼티 기능을 담당하는 Member 클래스와 데이터베이스 기능을 담당하는 MemberRepository 
    클래스 두 가지로 분리시켰다. 각 클래스는 연관된 기능들이 모여 있어 **목적에 따라 높은 응집력을 갖추게 되었다**. 그렇다면 다시 한 번 회원 
    데이터에 이름 컬럼을 추가해보자.

    ![case4](https://user-images.githubusercontent.com/78818063/177000130-c6a41b9d-2a56-46a6-bc40-88769ed6c3e6.png)

    이전 예제와 다르게 Member 클래스가 변경되어도 나머지 기능의 변경이 일어나지 않는다. 이는 프로퍼티와 데이터베이스 **클래스 두 가지를 추상화하여 
    책임을 분리했기 때문이다**. 이로써 서로 다른 목적을 모아둔 클래스는 **각기 다른 액터(호출자)에 의한 책임만을 가지게 되었고**, 해당 클래스는 단일 
    책임 원칙을 준수한다고 볼 수 있게 되었다.

<br>

결론적으로 단일 책임 원칙은 **특정 객체에 책임이 과중되는 현상을 방지**함과 동시에, **기능들이 서로 영향을 미치지 않도록 분리**시키는 설계 방식으로 
볼 수 있다. 이는 `객체 사이 결합도를 낮춰 유연성을 증가`시키며, `테스트 케이스를 줄여 테스트에 용이`하게 하며, 단 하나의 책임을 기준으로 설계하므로 
`개발 및 구현이 쉬워진다`. 또한 이는 클래스나 뿐만 아니라 넓게는 **모듈, 컴포넌트, 마이크로 서비스 등의 범주까지도 적용된 개념**이기 때문에 명확한 이해가 
필요하며, 과도하게 모든 기능을 분리시키면 더욱 이해하기 힘든 설계로 이어질 수 있어 많은 실전 경험에 익숙해지는 것이 바람직하다.

<br>
