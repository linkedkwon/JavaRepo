# 객체 지향 5대 원리, SOLID
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/SOLID-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## SOLID
`SOLID`는 여러 시행착오 끝에 정립된 **객체 지향 디자인 원리 다섯 가지를 의미하며, 애플리케이션 개발 시 유연함과 확장성을 동시에 갖추기 위한** 
지침서로 볼 수 있다. 해당 원칙은 **시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 유용**하다. 개발 결과물은 개발자로 하여금 
**가독성 높은 소스 코드를 제공하고 확장에 대한 강략한 유연함을 갖추어 보다 쉽게 리팩토링**할 수 있도록 한다. 아래는 다섯 가지 원칙들의 목록을 
간략하게 나타내고 있다. 

  * ### SRP(Single Responsibility Principle) 단일 책임 원칙 ###
    `단일 책임 원칙`은 객체를 설계 부품으로 취급하여 객체가 **오직 하나의 책임만을 가지는 것으로 수정할 이유가 단 한가지여야 함을 의미**한다. 
    이는 추상화된 객체의 책임을 개별적으로 분리시켜 객체 관계의 복잡도를 줄여준다. 다시 말해 소프트웨어의 응집도는 높이면서 결합도는 
    낮은 객체 관계를 정의할 수 있도록 한다. 

  * ### OCP(Open Closed Principle) 개방 폐쇄 원칙 ###
    `개방 폐쇄 원칙`은 **기존 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계하는 것을 의**미한다. 이는 객체 필드의 변경되는 
    사항들에 초점을 맞춰 자주 변경되는 내용은 수정하기 쉽게 설계하고 변경되지 않는 내용에는 영향을 받지 않도록 한다. 다시 말해, **자신(변경이 잦은 항목들)의 
    확장에는 열려 있고, 주변(변경되지 않는 항목)의 변화에 대해서는 닫혀 있는 것**이다. 보통 `인터페이스`로 기능을 분리하여 관리하는 방식을 
    가장 대표적인 개방 폐쇄 원칙의 적용이라 볼 수 있다.  

  * ### LSP(Liskov Substitution Principle) 리스코프 치환 원칙 ###
    `리스코프 치환 원칙`은 **상속 관계에 있는 상위 클래스는 항상 하위 타입으로 대체할 수 있도록 하는 것을 의미**한다. 이는 어떤 하위 객체에 접근할 때 
    상위 객체의 기능을 사용하더라도 아무런 문제 없이 일관성 있게 행동할 수 있어야 하며, 메소드의 사전 조건은 축소되지 않아야 하고, 사후 조건은 
    확대되지 않아야 한다. 즉 객**체들의 공통된 연산을 인터페이스로 정의함으로서 기본적인 추상화 기능을 일관성 있게 사용할 수 있고, 하위 클래스에서는 확장을 
    위해 구체화**한다. 따라서 해당 원칙은 **다형성과 확장성을 극대화할 수 있으며, 개방 폐쇄 원칙을 구성하는 방법**을 제공한다. 
    
  * ### ISP(Interface Segregation Principle) 인터페이스 분리 원칙 ###
    `인터페이스 분리 원칙`은 가능한 최소한의 인터페이스만을 정의하는 것으로, 필요하지 않은 요소를 구현하도록 강요하거나 사용하지 않는 요소에 
    의존하도록 만들지 않도록 함을 의미한다. 이는 단일 책임 원칙과 비슷한데, **쉽게 말해 객체가 사용하지 않는 인터페이스에는 영향을 받지 않아야 
    한다**. 만약 탈 것이라는 특징을 두고 차를 움직이고 짐을 실는 행위 두 가지를 인터페이스로 추상화하였다고 가정해보자. 이를 상속받는 하위 객체 
    승용차는 차를 움직이는 기능만을, 트럭은 움직이는 기능과 짐을 실는 행위 두 가지 모두가 필요하다. 이같은 경우 **해당 원칙을 적용하여 두 가지 
    행위를 한 곳에 두지 않고 각각 분리시켜 기능이 필요한 객체에서 상속받도록 해야 한다.** 즉 인터페이스의 **행위를 분리하여 시스템의 내부 의존성을 
    약화시켜 결합도를 낮추고 향후 유지 보수, 리팩토링, 개별적인 수정 및 배포 등의 작업에서 개별적인 객체의 작업만을 처리**하면 되므로 매우 효율적으로 
    개발에 임할 수 있다.

  * ### DIP(Dependency Inversion Principle) 의존 역천 원칙 ###
    `의존 역전 원칙`은 객체 사이 의존 관계를 구성할 때, **클래스 내부에 의존 대상을 두는 것이 아닌 외부에서 주입받도록 하는 것을 원칙**으로 한다. 
    이러한 의존성 주입이란 객체가 다른 클래스들에게 의존하는 것이 아닌 기본적으로 인터페이스나 추상 클래스와 관계를 맺도록 하여, 하위 레벨의 모듈이 
    상위 레벨 모듈의 변경을 요구하는 구조적 문제 발생을 방지시킨다. 즉 **객체 사이 의존성을 주입할 추상적 계층을 만들고, 이를 매개체로 하여 객체 간 
    의존 관계를 느슨하게 만들기 위한 원칙**이다. 해당 원칙을 사용하면 **복잡한 컴포넌트 관계를 단순화할 수 있으며, 커뮤니케이션을 효율적으로 처리해 편리한 
    설정과 함께 모듈을 보다 쉽게 제어**할 수 있다. 또한 **향후 수정이 일어날 때 이러한 추상 모듈의 수정만 진행**하면 되므로 높은 재사용성과 확장성 또한 갖추고 있다. 
    보통 프레임워크에서는 이같은 원칙을 적용한 `제어의 역전(IoC, Inversion of Control)` 기능을 제공하여 개발자로 하여금 로직 개발에만 집중할 수 있도록 
    한다. 

<br>

이처럼 소프트웨어를 객체 지향적으로 설계하기 위한 다섯 가지 원칙 SOLID의 간략한 정의에 대해 알아보았다. 해당 원칙을 적용하면 소프트웨어는 컴포넌트들의 
높은 재사용성을 제공받아 가독성 높은 코드, 개별적인 수정과 배포에 용이한 코드, 쉬운 유지 보수와 확장 설계, 테스트 유닛 개발과 주기적인 리팩토링 작업 등에 
매우 큰 도움을 줄 것이다. **객체 관계 구조를 설계할 때 해당 원칙이 코드에 잘 스며들도록 유의해야 하지만, 반대로 이러한 원칙에 집착하여 객체의 특성이나 
서비스의 본래 목적을 잃지 않도록 개발자는 더 많은 학습과 실전 경험을 쌍아야 할 것이다.** 위 다섯 가지 항목은 다음 하위 문서에서 실제 예시와 함께 보다 자세히 다루고 있다. 

<br>
