# 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/SOLID-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/LSP-blue"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 리스코프 치환 원칙이란?
`리스코프 치환 원칙`이란 상속 관계에서 **하위 클래스가 상위 클래스로 완전히 대체될 수 있어야 함**을 의미한다. 이는 사전에 
기획한 상속 관계에서 상위 클래스의 특성과 원칙이 잘 적용된 하위 클래스를 만들기 위해 사용된다. 즉 기존 의도에 어긋나거나 관계가 
모호한 경우 등 무분별한 하위 클래스의 생성을 막기 위한 일종의 규약으로 볼 수 있다.

![lsp](https://user-images.githubusercontent.com/78818063/177296742-5b1b7a3f-c2e0-4772-967d-fca0331eb721.png)

위 그림처럼 리스코프 원칙은 상속 관계를 조직도나 계층도의 형태로 표현하는 것이 아니다. 상위 클래스에서 정의한 행위는 **하위 클래스가 
사용함에 있어 논리적으로 합당해야 하며, 상속하여 표현하고자 하는 객체의 특성이 잘 드러나야 한다**. 이같은 이유로 해당 원칙이 잘 적용된 
하위 클래스는 상위 클래스 타입으로 형변환하여 사용해도 아무런 문제가 없다.

<br>

## 2. 사용하는 이유
앞서 단일 리스코프 원 칙의 정의에 대해 알아보았는데, 해당 원칙이 의미하는 바를 보다 자세히 이해하기 위해 아래에서 원칙이 적용된 코드와 
그렇지 않은 코드 두 가지를 비교해 보자.

  * ### 적용되지 않은 경우 ###
    먼저 원칙이 적용되지 않은 경우로 아래 코드는 일반 항목과 한정판 상품 두 가지를 결제하는 로직을 예로 들고 있다. 한정판 상품 클래스 
    LimitiedProduct는 일반 상품 클래스 Product를 상속받으며, **할인이 적용되지 않는 특징**을 가지고 있다.

    ![case1](https://user-images.githubusercontent.com/78818063/177296746-abe90b4e-f441-42cf-be06-0d8e889eeb22.png)

    다음은 상품을 구매하는 purchase() 메소드를 살펴보자. 제품 객체를 인자로 받아 결제 로직을 수행하는데, 이때 할인을 제공하기 위하여 상품의 한정판 
    여부, 즉 클래스 타입을 구분하기 위해 `instanceof` 연산자를 사용한다. 이는 흔한 리스코프 치환 원칙 위반 사례인데, 하위 타입인 LimitedProduct 
    클래스의 내부를 자세히 보면 할인율을 저장하는 멤버 변수를 따로 관리하지 않는다. 즉 **하위 클래스로 상위 클래스를 대체하지 못하는 상황이 발생**하며, 
    이같이 **새로운 종류의 하위 타입이 생길 때마다 상위 타입을 사용하는 코드를 수정해야 할 가능성이 높아져, 끝내 개방 폐쇄 원칙을 위반할 확률이 매우 높아진다.** 
    그렇다면 아래에서 원칙이 적용된 코드를 살펴보자.    

  * ### 적용된 경우 ###
    원칙이 적용된 예시로 이전 예제와 달리 **내부 기능을 추상화**하여 리스코프 치환 원칙을 적용하고 있다. 

    ![case2](https://user-images.githubusercontent.com/78818063/177296749-0dc1a2dc-e398-4398-80c0-1397c94e6422.png)

    상품의 한정판 여부를 확인하는 **isLimited() 메소드는 상위 클래스에서 추상화 및 하위 타입에서 재정의**되고 있으며, 각 클래스의 특성을 맞게 적합한 값을 
    리턴해주고 있다. 이같은 추상화 작업을 통해 purchase() 메소드는 **별도의 타입 구분 없이 단지 해당 메소드만으로 작업에 필요한 요구 사항을 수행할 수 있게 
    되었고, Product 클래스는 개방 폐쇄 원칙 또한 적용되어 보다 유연성**을 가질 수 있게 되었다.

<br>

결론적으로 리스코프 치환 원칙이 잘 **적용된 코드는 상속 관계를 적절히 구조화하고 하위 클래스의 생성 규칙을 제시할 수 있다**. 파생된 하위 
클래스들의 **세부 사항을 알지 못해도 상위에 포함된 모든 메소드를 사용할 수 있기 때문**이다. 또한 해당 원칙이 적용되면 추상화와 다형성을 
통한 확장 원리인 `개방 폐쇄 원칙(OCP, Open Closed Principle)`을 구성할 수 있어 `기존 코드의 변경 없이 확장이 가능`하며, 하위에서 
정의한 필드는 상위 메소드로 `감시할 대상이 아니기 때문에 안정적으로 수정`할 수 있다. 이처럼 두 원칙은 서로 포함되는 특징을 가지고 있어, 
**리스코프 치환 원칙을 준수하는 상속 구조를 만들고 이를 바탕으로 개방 폐쇄 원칙을 적용**해 클래스를 안정적으로 확장하는 것이 주요 목적으로 볼 수 있다.

<br>
