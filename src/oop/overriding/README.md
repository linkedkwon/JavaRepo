# 메소드의 다형성, 오버라이딩(Overriding)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Overriding-yellow" style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 오버라이딩이란?
`오버라이딩`은 **상속 관계에 있는 상위 클래스의 메소드를 하위 클래스에서 재정의하는 기능**을 의미한다. 기본적으로 하위 클래스는 상위 클래스 
필드 중 private 접근 제어자로 선언된 메소드를 제외한 모든 메소드를 상속 받을 수 있다. 따라서 Java에서 제공하는 오버라이딩을 사용하면 
아래와 같이 각 객체의 특성을 보다 잘 살린 새로운 메소드로 재구성할 수 있다.

![overriding](https://user-images.githubusercontent.com/78818063/174488133-f437d68a-e775-4e2e-9507-e73715b0f950.png)

<br>

## 2. 사용하는 이유
앞서 오버라이딩은 상속받은 메소드를 재정의하기 위한 기능으로 하위 클래스에서 상위 클래스의 메소드를 재사용하여 기능을 재구성하는 것을 
알 수 있었다. 이는 객체 지향 프로그래밍의 주요 특징 중 하나인 **다형성을 나타내는데**, 이를 활용하면 같은 기능을 가진 하위 클래스들의 
각기 다른 특성을 손쉽게 나타낼 수 있다. 이는 **동일한 메소드를 재사용하여 해당 내용만 달리 작성**하면 되므로, **중복되는 코드를 제거하여 가독성을 
높이고 코드를 일관성 있게 유지**할 수 있다.

<br>

## 3. 사용법
마지막으로 오버라이딩을 사용하는 방법에 대해 다룬다. 오버라이딩은 상속 관계에서만 제공되는 기능으로 상위 클래스에 속해 있는 메소드의 
**시그니처(Signature)를 하위 클래스에서 그대로 유지한 채로 구현부만 바꿔주면 된다**. 아래는 기본 오버라이딩의 사용법과 함께 지켜야 
할 조건에 대해 설명하고 있다. 

![overridingCase](https://user-images.githubusercontent.com/78818063/174488138-cd105c2e-577f-404b-b368-dd4d50cef07f.png)

* 메소드의 선언부가 기존 메소드와 완전히 동일해야 한다.
* 기존 메소드보다 접근 제어자를 더 좁은 범위로 선언할 수 없다.
* 기존 메소드보다 더 큰 범위의 예외를 선언할 수 없다.

<br>

다음은 메소드를 오버라이딩 할 때 사용하는 유용한 기능으로, 아래 코드와 같이 **오버라이딩 시 메소드 선언부 위에 `@Override 어노테이션(Annotation)`을 
작성하면 해당 메소드가 오버라이딩 되었단 사실을 명시적으로 선언**할 수 있다. 이는 클래스 내에 수많은 메소드 중 어떤 메소드가 재정의된 것인지를 알려주는 기능인데, 
실제로 위 어노테이션을 사용하지 않아도 오버라이딩을 수행하는데는 전혀 문제가 없다. 그럼에도 불구하고 이처럼 오버라이딩 여부를 명시하는 것이 좋은 이유 무엇일까? 

![annotation](https://user-images.githubusercontent.com/78818063/174488141-b93558b6-058e-456b-8feb-aee7e702530b.png)

오버라이딩은 **런타임 시점에 타입을 검사**하는 `동적 바인딩 방식`을 사용한다. 하위 클래스에서 **재정의된 메소드는 실제로 상위 클래스에 속해 있기 때문에 해당 
**메소드를 호출하는 객체가 무엇인지 컴파일 타임에는 알 방법이 없다**. 즉 **런타임 시점에 해당 메소드를 호출한 객체와 클래스를 확인하여 판단**하는 것이다. 
이같은 동작 원리에 따라 Java에서는 컴파일 타임에 오버라이딩이 제대로 구현되었는지 문법을 검사할 수 있는 `@Override 어노테이션`을 제공한다. 해당 어노테이션을 
사용하면 앞서 살펴본 조건에 따라 오버라이딩 메소드가 잘 구현되었는지 확인하며, 만약 **문제가 있을 경우 컴파일 타임에 오류를 발생**시킨다. 

<br>
