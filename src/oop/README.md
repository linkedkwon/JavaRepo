# 객체 지향 프로그래밍, OOP(Object-Oriented Programming)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 객체 지향 프로그래밍이란?
기존 `절차 지향 언어`는 구조적 프로그래밍의 일종으로 프로그램을 **기능(또는 명령)의 관점에서 해석하여 각 명령을 수행하는 프로지서(또는 함수)  
집합으로 구성**하였다. 또한 데이터는 전역과 지역의 두 가지 범위를 사용하는데, 각 프로시저에서 필요한 데이터는 파라미터와 반환 값을 주고 받아  
처리하였다. 이러한 방식은 향후 데이터의 처리 및 송수신이 중요하게 여겨지는 여러 비즈니스 서비스가 등장하면서 큰 문제점을 가지게 되었는데  
**데이터의 처리 과정(명령)은 구조화할 수 있지만, 데이터 그 자체를 구조화하지 못한다**는 것이다. 즉 이러한 문제를 해결하기 위해 프로그램을 **데이터의  
관점에서 해석**한 `객체 지향 프로그래밍`이 등장하였다.

![differ](https://user-images.githubusercontent.com/78818063/170218700-d3b136c4-c4ce-4ebb-85fd-3bc7ab6db9d6.jpeg)

위 그림처럼 절차 지향 언어는 함수의 호출을 추상화하여 재사용하고 있으며, 함수와 데이터를 별개 요소로 취급하여 다룬다. 반면에 객체 지향 언어는  
**실제 사물을 데이터의 속성(필드)와 행위(메소드)의 두 가지를 가진 객체로 표현**하며, **프로그램을 여러 객체 간의 관계와 상호작용**을 통해 나타낸다.

<br>

## 2. OOP의 4가지 특성
객체 지향 언어는 주로 규모가 큰 애플리케이션에서 사용하기 적합한데, 객체를 어떻게 설계하느냐에 따라 관련 데이터들은 높은 `응집력`과 서로 다른 객체 간  
낮은 `결합력`을 가져 **유지보수와 재사용에 적합**하기 때문이다. 그렇다면 이러한 장점을 가질 수 있도록 하는 객체 지향 언어의 주요 특징들을 아래에서 살펴보자.  

  * ### 추상화(Abstraction) ###
    <img width="672" alt="abstract" src="https://user-images.githubusercontent.com/78818063/170222528-1cf66abf-b09c-46df-93c3-b59eb486d1a3.png">
    
    `추상화`는 **중요하지 않은 기능들을 숨기고 관련 정보만 알 수 있도록 하는 기법**을 의미한다. 상세한 구현을 숨겨 객체들로 하여금 복잡성을 줄여주며  
    다형성을 지원하는 인터페이스나 상속 클래스 등으로 확장이 가능케 한다. 추상화 방식은 데이터와 제어를 기준으로 두 가지로 분류할 수 있다. 먼저  
    `데이터 추상화`는 **복잡한 객체를 표현하기 위해 하위의 속성 데이터들를 정의하는 방법**으로, 위 예제는 캐릭터란 객체를 표현하기 위해 클래스 내부에  
    능력치의 하위 필드로 구성되어져 있다. 다음으로 `제어 추상화`는 **메소드와 같은 로직의 내부 로직이 수정되더라도 별다른 문제없이 외부에서 사용할  
    수 있도록 한다**. 사용자는 내부 로직이 어떻게 구성되고 변경된 것인지 알 필요 없으므로 해당 행위를 이해하고 필요에 따라 적절히 잘 활용하면 된다.

  * ### 캡슐화(Encapsulation) ###
    <img width="672" alt="encapsulation" src="https://user-images.githubusercontent.com/78818063/170222575-bc9eb1f2-f36f-458c-b03e-8cb03ca5cc54.png">
    
    앞서 서로 관련된 속성과 행위를 묶어 표현한 것을 객체라 정의하였는데, `캡슐화`는 이러한 객체를 **관련있는 데이터끼리 응집시키고 외부에서 쉽게  
    접근하지 못하도록 은닉시키는 방법을 의미**한다. 사용할 객체로부터 직접적인 접근을 막고 외부에서 내부의 정보에 직접 접근하거나 변경할 수 없으며  
    내부에서 제공하는 필드와 메소드를 통해서만 접근이 가능하다. 객체는 **속성과 행위를 묶어 데이터 간의 응집도가 높아져, 객체로 하여금 능동적인 속성**이  
    부여된다. 만약 **외부에서 객체 내부에 직접 접근하면 해당 객체는 높은 결합도와 낮은 응집도를 지닌 수동적인 객체**가 된다. 이러한 객체는 외부에서  
    마음대로 객체 상태에 관여할 수 있으므로 **보안 문제와 직접적으로 연결**된다. 따라서 필드에 적절한 `접근제어자`를, 공개 메소드를 `인터페이스`로 분리해  
    책임과 역할을 분리시켜 외부에서 객체로의 의존성을 없애고, 서비스에서 중요한 데이터를 전달해야 한다면 `불변 상태`로 유지시키는 등의 캡슐화를  
    적절히 사용하는 것이 바람직하다.
    
  * ### 상속(Inheritance) ###
    <img width="669" alt="inherit" src="https://user-images.githubusercontent.com/78818063/170222595-9c11652a-47f0-428f-a77a-f400a24804a3.png"> 
    
    `상속`은 추상화에 의미를 더해 **여러 객체가 가진 공통의 속성과 행위를 추출하는 과정**을 의미한다. 객체들의 공통점을 찾아내어  
    해당 특성을 공유할 수 있는 상위 클래스를 설게하는 작업이다. 기능과 특성을 표준화하여 확장하기 좋고, 공통적인 작업을 한 곳에서   
    관리하므로 재사용과 유지보수에 용이하다. 보통 상위 클래스에서 제공하는 필드 값을 초기화하기 위해 상위 클래스의 생성자에  
    `super()`를 사용해 접근이 가능하다.

  * ### 다형성(Polymorphism) ###
    <img width="671" alt="poly" src="https://user-images.githubusercontent.com/78818063/170222610-a2d725ac-1fcc-4a1e-9ee0-cbae414668bb.png">
    
    `다형성`은 같은 **자료형에 여러 가지 객체를 대입해 다양한 결과를 갖도록 하는 성질을 의미**한다. 이러한 특성은 동일한 이름을 가진  
    여러 형태의 메소드를 만들 수 있는데 대표적으로 프로그램에 사용된 구성 요소의 실제 값 또는 속성을 결정짓는 `바인딩`에 활용된다.  
    바인딩은 컴파일 시점과 런타임 시점 두 가지 시간에 일어난다. 먼저 `컴파일 시점`에는 컴파일러가 메소드 호출에 필요한 모든 정보를  
    이미 인지하고 있어 적절히 메소드를 각 객체에 바인딩 할 수 있다. 이를 **정적 바인딩**이라 부르는데, 대표적인 방법은 **오버로딩으로  
    메소드의 반환 타입과 이름을 같게 만들고 매개 변수로 각 메소드를 구분짓는다**. 다음으로 `런타임 시점`에 사용하는 **동적 바인딩**은  
    주로 **상속 관계에서 사용되는 오버라이딩을 예로 들 수 있는데, 상위 클래스에서 생성된 메소드를 하위 클래스에서 다시 재정의하여  
    사용하는 방법**이다. **하위 클래스에서 재정의된 메소드는 실제로는 상위 클래스에 속해 있으므로, 해당 메소드를 직접 호출하는 객체가  
    무엇인지를 컴파일 타임에는 알 방법이 없다**. 즉 런타임 시점에 메소드를 호출한 객체가 무엇인지 확인하여 판단한다. 즉 오버로딩과  
    오버라이딩은 메소드를 재사용하여 기능의 재구성을 원칙으로 한다. 결론적으로 다형성을 활용하면 기능을 확장하거나 객체를 변경해야  
    할 때 타입 변경 없이 객체를 주입하여 손쉽게 수정이 가능하며, 중복되는 코드를 제거하고 이를 재사용할 수 있다.
    
<br>
