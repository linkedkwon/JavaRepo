# 추상 클래스(Abstract Class)와 인터페이스(Interface)의 차이점과 접근법
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/AbstractInterfaceCompare-yellow" style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 추상 클래스와 인터페이스?
추상 클래스와 인터페이스는 내부적으로 `추상 메소드(abstract method)`를 포함하고 있기 때문에 이를 상속받은 클래스는 **반드시 기능을 구현**해야 한다는 
점을 기본으로 시작한다. 이러한 출발점으로 인해 두 기능을 사용했을 때 얻을 수 있는 **이점들이 매우 비슷**하다. 객체 관계 구조에서 관심사를 분리시켜 독립적인 
프로그래밍이 가능하며, 협업에 있어 표준을 명시하여 생산성과 유지 보수에 효율을 높이고, 모두 상속 기능이 바탕이 되므로 하위 클래스들의 특성을 살릴 수 있는 다형성이 적용된다. 
이처럼 사용했을 때 얻을 수 있는 이점들이 매우 비슷해 두 기능의 차이점과 사용 목적을 명확히 이해하기 힘들 수 있다. 또한 이같은 장점을 적용하기 위해 모든 클래스를 추상 클래스로 
정의하고 기능들을 무분별하게 인터페이스로 분리시킬 수도 있다. 따라서 이번 항목에서는 두 가지 기능의 차이점과 각각 어떻게 사용해야 하는지와 같은 접근법에 대해 다루도록 한다.

<br>

## 2. 차이점
기본적으로 추상 클래스는 `is a kind of(~의 한 종류)`, 인터페이스는 `be able to(~을 할 수 있는)`으로 정의하고 있다. 
그렇다면 두 기능의 차이점을 아래 항목에서 자세히 알아보자.

  * ### 내부적인 차이 ###
    공통적으로 두 기능 모두 **필드에 추상 메소드를 포함**하고 있다. 하지만 추상 클래스는 추상 메소드를 하나 이상 포함하고 **나머지 기능은 모두 일반 클래스처럼 사용 가능**하다.
    반면에 인터페이스는 **일반 메소드는 허용하지 않고 상수 변수만을 두는 것을 원칙**으로 한다. 즉 **추상 클래스는 기본 상속의 이점과 함께 공통 기능을 가진 하위 클래스를 군집화하고 
    확장하는 역할을 제공하고 인터페이스는 여러 클래스들의 공통 기능을 분리하여 확장하는데 초점**에 둔다.

  * ### 사용 목적 ###
    사용 목적은 키워드를 통해 유추 가능하다. 상속의 `extends`는 **기능 구현 + 확장**을, 인터페이스의 `implements`는 **기능 분리 + 구현**에 초점을 두고 있다. 
    인터페이스의 역할은 추상 클래스에서도 이미 제공하고 있다고 생각할 수 있지만, **객체 관계 구조와 함께 생각해보면 인터페이스의 사용 의도**를 정확히 파악할 수 있다. 
    일반적으로 **상속은 여러 가지 클래스들이 다중으로, 또 계층 구조를 형성**하고 있어 하위 클래스들은 자신이 상속받은 상위 클래스들의 특성과 기능을 모두 물려받을 수 있다. 
    하지만 **상속만으로 공통 기능을 정의하고 활용할 수 없는 경우**가 존재한다. 아래 두 가지 예시를 살펴보자.
    
    * ### 상황1. 상속 관계가 형성되지 않은 상태에서 공통 기능이 필요한 경우 ###  
      만약 **상속 관계가 형성되지 않은 서로 다른 클래스가 같은 기능을 기잔다면** 어떻게 해야 할까? 가장 단순한 방법은 `(방법1) 각각 필요한 기능과 코드를 구현`하는 것이다. 
      이 경우 **코드가 중복되고 같은 공통의 기능을 묶을 수 없다**. 따라서 이러한 문제를 보완하기 위해 기능을 관리하는 `(방법2) 새로운 클래스를 만들어서 상속받아` 보자. 이 방식은 
      해당 클래스가 **이미 상속을 받고 있는 경우는 사용할 수 없으며**, 만약 상속이 가능하다 해도 기회 비용이 너무 크고 **클래스가 확장되면 이 문제는 다시 원점으로 돌아온다**. 
      마지막으로 해당 기능을 모아둔 클래스를 사용해 생성자나 메소드를 통해 `(방법3) 주입(Dependency Injection)받아` 해결해보자. 주입 방식은 공통 기능을 분리할 수는 있지만 
      **기능 구현에서 다형성을 제공하지 못하고, 강제 구현을 통한 표준 명시, 관심사를 분리하고 객체 간 의존성을 낮추 등 앞서 배운 모든 이점들이 사라진다.** 
      
    * ### 상황2. 상속 관게가 형성되어 있지만 모든 하위 클래스에서 기능을 필요로 하지 않는 경우 ###  
      다음 예시는 **상속 관계가 형성되어 있지만 하위에 있는 모든 클래스가 공통으로 기능을 사용하지 않는 경우다**. 당연하게도 추상 메소드의 특징에 따라 추상 클래스 설계 자체가 
      애초에 불가능하다. 이러한 경우는 해당 기능이 필요한 하위 클래스들이 상속받고 있는 `(방법) 가장 최하단의 클래스를 찾아 일반 메소드로 구현`하고 **하위 클래스에서 오버라이딩하여 
      해결 가능**하다. 하지만 이 방식은 위 예시와 마찬가지로 **표준 명시, 관심사 분리와 같은 기본 장점이 없어진 일반적인 상속 방식**이다. 
    
    이처럼 복잡한 객체 관게 구조에서는 상속만으로 공동 기능을 관리할 수 없고, 앞서 언급했던 이점들이 적용되지 않는다. 이떄 사용하는 것이 인터페이스다. **인터페이스는 이렇게 
    상속 관계로 정의할 수 없는 행위(Method)들을 분리하고 구현할 수 있도록 한다.** 해당 기능이 필요한 클래스들만 인터페이스를 상속받아 재정의할 수 있으며, 
    **객체의 관계 구조에 직접적인 영향을 주지 않고 독립적으로 기능을 운용할 수 있다**.
    
  * ### 다중 상속 여부 ###
    상속은 단 하나의 클래스만 상속이 가능하지만, 인터페이스는 **다중 상속**이 가능하므로 기능을 분리시켜 자유롭게 클래스들의 행위를 지정할 수 있다. 

<br>

## 3. 접근법
앞서 추상 클래스와 인터페이스의 차이점과 함께 사용 목적을 자세히 알아보았는데, 이러한 **두 기능을 절대 무분별하게 사용해서는 안된다.** 
**객체 관계 구조와 함께 반드시 필요로 할 때 사용**해야 하는데, 아래 항목에서 구체적인 사용 접근법에 대해 알아보자.  

<img width="756" alt="abstract_interface_hierarchy" src="https://user-images.githubusercontent.com/78818063/172769003-a95830e0-7dfe-4f7b-ab51-0b40101a1de8.png">

  * ### 추상 클래스 ###
    먼저 `하위 계층에서 상위 계층으로 올라가는 경우`, **다중 상속 관게에서 같은 상위 클래스를 상속하는데 기능까지 완벽히 같을 때 해당 클래스를 추상 클래스로 선언한다.** 
    그리고 `상위 게층에서 하위 게층으로 내려가는 경우`, 상속은 단 한 번만 허용되기 때문에 같은 기능을 가진 **최상위 클래스와 하위 클래스들 사이에 추상 클래스를 두어 
    특성에 맞게 다시 클러스터링(Clustering)할 수 있다**. 이렇게 중간 매개체 역할로 **객체를 구조화 할 수 있으며**, 동시에 **군집화된 하위 클래스에게 물려줄 특성을 더 추가할 수 있다**.

  * ### 인터페이스 ###    
    인터페이스는 반드시 서로 다른 클래스에서 **공통된 기능이 발견됬을 때만 만들어야 한다**. 여기서 가장 주의할 점은 무분별하게 인터페이스를 제작해 기능을 분리하지 않는 것이다. 
    **클래스들이 공동 기능을 분리한 추상 클래스(또는 일반 킅래스)를 상속받지 않고 있어야 하고, 만약 상속이 되어 있더라도 다른 하위 클래스에서 기능이 필요없어 분리해야 하는 경우**에만 
    사용하는 것이 바람직하다. 위 예시를 먼저 보면 차가 달리고 사람이 타는 행위를 나타내는 **move()와 ride()는 하위에 속해 있는 모든 클래스들이 기능을 강제 구현해야만 한다. 따라서 
    가장 최상위에 있는 추상 클래스 Vehicle에서 정의**하고 있다. 반면에 짐을 실는 행위인 **load는 인터페이스로 정의하였다. 이는 짐을 실는 기능이 최하위 클래스 Sedan에는 포함되어 있지 
    않아 Vehicle이나 Motor에서는 정의할 수 없으며, 상속 관계가 다른 Truck에서는 해당 기능이 필요**하기 때문이다. 이렇게 복잡한 객체 관계에서 공통으로 사용되는 기능을 인터페이스로 
    분리해야 한다. 만약 SUV 클래스가 load 기능을 필요로 하지 않았다면 Truck 클래스에서 자체적으로 메소드(추상, 일반 포함)를 두어 기능을 정의할 수 있었을 것이다. 
    이처럼 기능이 필요한 클래스의 관계 구조가 단순하다면 상속만을 사용해 충분히 기능을 분리시킬 수 있다. 반면에 **객체 관계 구조가 복잡하거나 확장 시 재사용 될 것으로 예상되는 
    기능들은 인터페이스로 정의하는 것이 바람직하며, 다중 상속이 가능하기 때문에 내부에는 각 목적에 맞는 최소한의 메서드만을 선언하는 것이 좋다.**  
    
<br>
