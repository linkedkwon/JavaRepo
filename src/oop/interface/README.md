# 구현 설계도 인터페이스(Interface)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/OOP-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Interface-yellow" style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 인터페이스란?
`인터페이스`는 클래스를 설계할 때 **동일한 행위(Method)와 인스턴스 간 공유되는 상수를 추출**하여 모은 추상 자료형이다. 정확하게는 `상수`와 
`추상 메소드(Abstract Method)`의 집합을 의미한다. 클래스에서 인터페이스를 상속받으면 **내부에 포함된 모든 추상 메소드를 반드시 
재정의(Overrriding)해야 한다**. 따라서 설계에 있어 기본 틀을 제공하는 표준, 약속, 규칙을 명시하고 다른 클래스 사이 중간 매개 역할을 담당한다.

<img width="573" alt="skill" src="https://user-images.githubusercontent.com/78818063/172533291-65c12bf7-df09-4593-a082-dd6771cf0aba.png">

위 코드는 인터페이스의 간단한 예시를 나타낸다. 변수를 선언하면 컴파일 과정에서 `public static final` **예약어가 자동으로 붙어 상수로 정의**되며, 
메소드 또한 `public abstract` **예약어가 자동으로 등록**된다. 그리고 추상 클래스와 마찬가지로 구현체가 없어 **단독으로 인스턴스 생성이 불가능**하다.

  * ### default 키워드 ###
    Java 8에서 등장한 `default` 키워드를 인터페이스의 **메소드에 추가하면 메소드 내부에 구현체를 둘 수 있다**. 이는 일반적인 부모 클래스의 
    메소드처럼 사용이 가능하고 해당 메소드를 **하위 클래스에서 재정의할 수도 있다**.  
    
    <img width="570" alt="default" src="https://user-images.githubusercontent.com/78818063/172533306-8e32af73-5ca2-4bc2-823b-32aca6c1a580.png">
    
  * ### 특징 정리 ###
    앞서 살펴본 인터페이스는 추상화를 통해 **공통 기능과 상수를 분리하고 상속을 통해 다형성을 제공**한다. 이는 클래스 설계 시 기본 틀과 
    규격을 명시하고 구현을 강제하여 **설계 의도를 직접적으로 드러낸다**. 따라서 인터페이스를 보통 `밑그림만 있는 설계도`라 칭하는데, 
    아래에서 다시 인터페이스의 여러 특징을 살펴보자.

    * #### 구현의 의미를 지닌 implements 키워드를 사용해 상속한다. ####
    * #### 추상 메소드와 상수를 멤버 변수로 갖는다. ####
    * #### 상수는 public static final, 메소드는 public abstract 키워드가 자동으로 정의된다. ####
    * #### Java 8부터는 static, default 키워드가 메소드에서 사용 가능하다. ####
    * #### 다중 상속이 가능하다. ####
    * #### 내부에 구현체가 없어 단독으로 인스턴스 생성이 불가능하다. ####
    * #### 인터페이스를 상속 받으면 내부에 포함된 메소드를 하위 클래스에서 반드시 재정의해야 한다. ####

<br>

## 2. 사용하는 이유
이처럼 인터페이스는 객체 지향 프로그래밍에서 설계 시 기본 골격을 제시하고 행위가 다형성을 갖도록 하는데, 이와 관련하여 실제 **실무에서 
사용했을 때 가지는 이점**이 대해 알아보자.

  * ### 개발 표준화 ###
    인터페이스는 메소드를 기본적으로 추상 메소드로 정의하므로 반드시 하위 클래스에서 이를 재정의해야 한다. 즉 **공통 기능들의 규격과 틀을 
    설계하였기 때문에 협업에 있어 표준을 명시**할 수 있다.
    
  * ### 관심사 분리 ###
    객체들이 사용할 공통 기능을 추출하여 정의하기 때문에 설계 관점에서 **행위들을 군집화시키고 관계 구조를 단순화**한다. 즉 설계와 개발의 역할을 
    분리하고 단순화 시켜 생산성을 향상시킬 수 있다.

  * ### 느슨한 결합(Loose Coupling) ###
    인터페이스를 사용하면 **확장에는 열려 있고 변경에는 닫혀 있는** `개방폐쇄(Open Close) 원칙`이 적용 가능하다. 만약 게임을 예로 들면, 
    각 캐릭터가 가진 특성과 행위의 종류는 동일하더라도 내부의 상세 구현 내용은 모두 재각기 다를 것이다. 매번 새로운 캐릭터가 추가될 때 마다 
    해당 캐릭터를 대변하는 **새로운 인터페이스(또는 클래스)를 만들지 않고 행위들을 특성에 맞게 재정의**하는 것이 바람직하다.
    즉 객체의 관계로 프로그램을 표현함에 있어 **서로 간의 의존도와 결합도를 낮추면 특정 클래스의 변경이 관계된 다른 클래스에게 
    영향을 미치지 않아** 유연한 프로그래밍이 가능하다.
    
  * ### 다중 상속 ###
    기본적으로 `상속은 기능의 확장(Extends)을 의미`한다. 따라서 상위 클래스를 단 하나 밖에 둘 수 없는데, 기능 확장이 많이 필요하면 
    **직접 체이닝(Chaining)된 구조를 설계**해야 한다. 반면에 `인터페이스는 기능의 구현(Implements)을 의미`하기 때문에 다중으로 상속이 가능하다. 
    따라서 행위들을 특성에 따라 쉽게 구조화하고 사용할 수 있으므로 유연한 설계가 가능하다.  

    <img width="569" alt="multi-implements" src="https://user-images.githubusercontent.com/78818063/172533313-2cdd851c-fda3-4c20-a38c-5865dd1dd55b.png">

<br>

## 3. 사용법
마지막으로 인터페이스의 사용법을 다루고 글을 마친다. 사용법은 매우 간단한데, **하위 객체들의 특성에 따라 적절히 메소드를 재정의**하여 사용하면 된다.

  * ### 인터페이스 ###
    먼저 인터페이스를 정의하는 방법으로 내부에 사용할 **공통의 상수와 메소드를 정의**한다. 키워드를 명시하지 않아도 자동으로 정의되며, 
    만약 상속과 같이 구현체가 있는 메소드를 두고 싶으면 default 키워드를 메소드 앞에 사용한다.  

    <img width="568" alt="interface" src="https://user-images.githubusercontent.com/78818063/172533326-59120489-fac7-4a54-9586-f691587a06d3.png">
    
  * ### 하위 클래스와 추상 메소드 오버라이딩 ###
    인터페이스를 **상속 시**켜 하위 클래스에서 해당 메소드를 **재정의**하고, 각 객체의 특성에 알맞는 로직을 구현하도록 하자. 
    아래 코드는 게임에서 각 챔피언마다 사용하는 스킬을 각기 다르게 재정의하고 있다.  

    <img width="579" alt="overriding" src="https://user-images.githubusercontent.com/78818063/172533333-604364eb-1256-46cb-94b6-e1927e2266e4.png">

<br>
