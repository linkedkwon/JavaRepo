# 스레드 동기화(Thread Synchronization)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Thread-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Synchronization-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 동기화(Synchronization)?
`동기화`란 프로세스 또는 스레드의 작업 수행 시점을 조정하여 **서로가 공유할 자원 정보를 일치시키는 행위를 의미**한다. 쉽게 말해 특정 
스레드가 자원을 점유하고 있을 때(읽기인 경우는 무관), 이를 제외한 **나머지 스레드들은 해당 자원에 접근할 수 없도록 막는다**. 이러한 
동기화 작업이 없다면 공유 중인 데이터의 안정성과 신뢰성을 보장할 수 없는데, 아래 예시를 통해 이해해보자.

![pic1](https://user-images.githubusercontent.com/78818063/179431120-81615713-336d-464e-a64b-20c72d92de3d.png)

만약 두 개의 스레드 A와 B가 있고 모두 같은 변수 C를 참조하고 있다고 가정해보자. 위 그림에서 스레드 A는 변수 C를 참조하고 있고(Read), 
스레드 B는 변수 C를 다른 값으로 변경(Write)하고 있다. 두 작업이 동시에 일어난다면 특정 스케줄링이나 제어 작업을 걸어두지 않았을 경우 
스레드 A는 전혀 관계 없는 C값을 가질 확률이 높다. 이처럼 **두 개 이상의 스레드(프로세스, 변수 등 동일)가 동기화 없이 자원을 공유하는 
상황**을 `경쟁 상태(Race Condition)`라 부르며, 다른 스레드가 접근할 수 없도록 막거나 `Thread-safe(스레드 안전, 동시 실행되어도 
결과에 지장없는 상태)`한 설계 등으로 자원 정보를 일치시키는 동기화 작업이 필요하다.

<br>

## 2. 스레드 동기화
앞서 살펴본 스레드를 동기화하기 위해 Java에서는 접근을 막는 임계영역을 정하는 키워드 또는 메소드를 통해 다른 스레드로부터의 접근을 
막을 수 있다. 아래 두 가지 사용법에 대해 알아보자.

  * ### Synchronized 키워드 ###
    가장 간단한 방법으로 임계영역으로 지정할 공간에 키워드를 붙여주면 해당 **영역이 실행될 때 가지고 있는 자원에 lock을 걸어 다른 
    스레드들이 접근하지 못하도록 강제**한다. 키워드는 메소드나 블럭에 적용 가능하다.

    ![case2](https://user-images.githubusercontent.com/78818063/179431125-aeee9eb0-c065-4092-9550-58bf005f63d0.png)

  * ### Wait(), Notify() ###
    스레드들이 처리할 서비스가 **서로 협력 관계에 있거나 교대로 작업을 처리해야 할 때 사용할 수 있는 방법**이다. **한 스레드가 작업이 
    끝나면 다른 스레드의 대기를 풀고 자신이 대기 상태로 들어가는 방식**을 취한다. 두 가지 메소드를 사용하는데, `wait()`은 스레드가 
    lock 권한을 가지고 있으면 이를 해제해 권한을 반납하고 대기 상태로 머물게 하고, `notify()`는 대기 상태인 스레드에게 다시 lock 
    권한을 부여해 로직을 실행시킨다. 여기서 주의할 점은 **두 메소드 모두 동기화 블럭에서만 사용해야 한다**.

    ![case3](https://user-images.githubusercontent.com/78818063/179431126-2a32819d-a66c-43b4-80af-63e84460286f.png)

    위 예제는 진열대에 상품을 놓을 수 있는 최대 개수에 따라 상품을 전시하는 로직이다. 점원은 상품을 진열하다 더 이상 놓을 공간이 없으면 
    wait() 메소드를 호출해 대기 상태에 들어가고, 진열대는 상품이 모두 추가됬으므로 notify()를 호출해 판매를 시작한다. 다음으로 모든 
    상품이 판매되면 더 이상 판매 로직을 수행할 수 없으므로 진열대는 다시 대기 상태로, 그리고 점원은 notify()를 호출해 다시 상품을 
    진열한다. 
    
<br>

위같은 두 가지 방식으로 스레드 간 동기화 처리를 쉽게 처리할 수 있다. 단 무분별하게 많은 동기화 작업이 일어나면 작업을 처리 중인 스레드들이 
모두 대기상태에 빠지므로 **성능 저하가 일어날 우려**가 크다. 따라서 반드시 필요한 경우에만 사용하고, 적절히 자원을 사용할 수 있도록 설계하여 
스레드 안정성을 구축하는 것이 바람직하다.

<br>
