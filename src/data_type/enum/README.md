# 열거형 상수, Enum(Enumerated Type)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Enum-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. Enum이란?
JDK(Java Development Kit) 1.5 버전에서 등장한 `Enum`은 열거형 상수, 즉 **서로 연관된 상수 집합을 다루는 자료형**을 
의미한다. 일반적으로 상수는 클래스 내부 필드에 선언해서 사용되는데, 기존에는 상수 값이 여러 개인 경우 해당 값을 담을 **별도의 
클래스나 인터페이스**를 생성하였다. 하지만 해당 방식은 아래 코드와 같은 몇 가지 문제점이 나타났다. 

<img width="777" alt="constant1" src="https://user-images.githubusercontent.com/78818063/169978633-d8b304c6-1f0b-4283-9ca9-e02f992a8849.png">

먼저 가장 기본적으로 클래스 필드에 **여러 개의 상수 값을 선언한 방식**이다. 변수에 static과 final 키워드를 함께 선언해 특정 리터럴 
값을 명시적으로 초기화하여 모든 인스턴스에서 공유할 수 있도록 선언하였다. 그리고 용도에 따라 의미를 바로 이해할 수 있도록 변수명을 작성하였다. 
하지만 이때 상수 필드가 너무 많아지면 리터럴 값은 다르지만 같은 용도를 가진 변수들의 **네이밍이 중복되는 상황이**가 발생한다. 이는 변수의 
특성이나 기능을 더 구체화하여 접두사나 접미사를 추가해 상수 필드를 유지할 수 있다. 하지만 점차 **변수들의 의미를 한 눈에 파악하기 힘들고, 
코드의 가독성이 낮아져 협업과 유지보수에 있어 매우 비효율적**인 결과를 초래한다. 

<img width="774" alt="constant2" src="https://user-images.githubusercontent.com/78818063/169978648-e4a626ce-b9c3-4ac3-abf6-924457a1adec.png">

이같은 문제점은 **인터페이스를** 사용해 위 코드처럼 각 필드를 **관심사에 따라 여러 집합으로 분리**할 수 있다. 각 집합을 포함한 인터페이스는 
비즈니스 로직에 따라 필요한 객체에서 상속받기 때문에 **중복된 변수명이 있어도 문제없이 사용**할 수 있다. 또한 **static final 키워드를 생략할 
수 있어 코드의 가독성도 조금 더 높아졌다**. 하지만 아직 해결하지 못한 사안이 한 가지 남아있는데, 마지막 메소드처럼 **서로 다른 타입의 인터페이스에서 
선언된 상수를 비교하면 컴파일 시점이 아닌 런타임 시점에 오류가 발생할 수 있다.** 즉 예기치 못한 런타임 에러로 서비스가 중단되는 상황이 발생할 수 있다.

<img width="777" alt="constant3" src="https://user-images.githubusercontent.com/78818063/169978654-5a9d1784-e547-4a25-a8fc-cb72928e563d.png">

따라서 앞서 인터페이스를 사용했던 방식을 **class**로 전환하였다. 그리고 상수의 관심사에 따라 집합을 분류하였고 내부 필드는 **접근 제어자를 
public으로 선언해 상수 값들을 유틸 필드처럼 사용**하도록 설계하였다. 클래스로 집합을 표현하여 이전과 같이 서로 다른 집합의 타입이 다른 경우 
컴파일 시점에서 오류를 확인할 수 있어 곧바로 수정이 가능해졌지만, **상수를 쉽게 다룰 수 있는 switch 문에서는 사용하지 못한다.**. 보통 상수 
값들은 switch 문과 함께 사용해야 가독성이 좋아져 코드에 높은 가독성을 부여할 수 있는데, 해당 조건에 들어가는 데이터 타입이 제한적이기 떄문에 
인스턴스를 그대로 넣어 각 상수 값으로 분류할 수 없다. 따라서 이러한 불편함과 문제점을 개선한 자료형 Enum이 등장한다.

<img width="777" alt="constant4" src="https://user-images.githubusercontent.com/78818063/169978656-f04d32ce-c355-43fb-a025-5ab9de6ee6a8.png">

Enum을 사용하는 방법은 먼저 Enum 타입의 클래스 파일을 만들고 **내부에 열거할 상수들을 선언**한다. 관례적으로 상수의 변수명은 모두 **대문자를 사용해** 
표현해야 하며, **여러 단어의 조합은 언더바**를 사용해야 한다. 그리고 생성된 Enum 객체는 클래스와 마찬가지로 **참조 타입**이기 때문에 위와 같이 객체를 
만들어 값을 사용해야 한다. 이때 **Enum은 Heap에 메모리가 할당되는 인스턴스와는 달리 내부적으로 statck 영역**에 할당되며, **상수가 참조하는 리터럴 
값의 실제 주소를 참조**한다. 이같은 메모리 할당 방식은 **내부에서 선언한 상수에 static과 final 키워드가 기본적으로 생략**되어 있기 때문이다. 
이제 내부에 여러 메소드를 두어 해당 객체와 상수 값을 쉽게 다룰 수 있다.  

<br>

## 2. Enum의 활용(생성자)과 이점  
<img width="779" alt="constant5" src="https://user-images.githubusercontent.com/78818063/169978661-b7d13fab-bde8-4dc3-aa0a-264fad97f2b1.png">

Enum은 열거할 상수에 **추가적인 속성을 부여**할 수 있다. 예를 들어 게시글을 작성할 때 제목과 본문의 허용되는 최대 글자 길이를 표현해야 
한다면 위 코드와 같이 속성으로 표현 가능하다. 그리고 생성자를 통해 **추가적인 속성을 내부의 필드 값으로 지정하고 getter와 같은 별도의 메소드를 
만들어 값을 반환받을 수 있다**. 즉 이런식으로 메소드나 필드를 Enum 내부에 추가해 **상수 데이터를 더욱 밀접하게 연관시키고 객체의 책임을 분리시킬 
수 있다**. 또한 한 가지 특이한 점으로 Enum의 생성자는 `private` 형태의 접근 제어자를 갖는다. 해당 이유는 앞서 말했듯 **내부의 상수들에는 
static과 final이 숨겨져 있어 고정된 상수 값이란 의미를 부여하기 위함이다. 따라서 Java의 컴파일러는 해당 변수들의 존재를 런타임이 아닌 컴파일 타임에 
알고 있어야 하므로 외부에서 동적으로 접근해 해당 상수들에 영향을 줄 수 없고, 이는 곧 강력한 타입 안정성을 부여**받는다. 즉 Enum을 통해 상수를 관리하면 
상수 집합 객체의 인스턴스 생성과 상속을 방지하고 해당 집합을 모두 `싱글톤`으로 관리할 수 있으며, 이외에도 아래와 같은 여러 이점을 가질 수 있다.

* **단순한 코드와 높은 가독성**
* **인스턴스 생성을 방지하여 타입안정성 보장**
* **컴파일 시 타입 안정성**
* **의도가 열거임을 명확히 표현**

<br>
