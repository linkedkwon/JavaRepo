# 열거형 상수, Enum(Enumerated Type)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Enum-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. Enum이란?
JDK(Java Development Kit) 1.5 버전에서 등장한 `Enum`은 열거형 상수, 즉 **서로 연관되어 있는 상수들을 모아둔 자료형**을  
의미한다. 일반적으로 상수는 클래스 내부 필드에 선언해서 사용되는데, 기존에는 상수 값이 여러 개인 경우 해당 값을 담을 **별도의  
클래스나 인터페이스**를 생성하였다. 하지만 이러한 방식들은 몇 가지 문제점을 가지는데, 아래에 코드와 함께 자세히 살펴보자.  

<img width="777" alt="constant1" src="https://user-images.githubusercontent.com/78818063/169978633-d8b304c6-1f0b-4283-9ca9-e02f992a8849.png">

먼저 가장 기본적인 방법으로 클래스 내에 **여러 개의 상수 값을 선언**한다. 각 변수들을 static과 final 키워드를 조합해 특정 리터럴  
값을 바로 명시적으로 할당하고 있으며, 모든 인스턴스에서 공유할 수 있도록 초기화하였다. 그리고 변수들의 특성에 따른 이름으로   
각각이 갖는 의미를 바로 이해할 수 있도록 하였다. 하지만 상수 필드들이 너무 많아지면 같은 기능을 가진 변수들이 생겨 **네이밍이  
중복되는 경우**도 많이 발생한다. 그렇다고 특성이나 기능에 따라 접두사나 접미사를 추가하여 그대로 필드들을 유지한다면 개발자는  
한 눈에 각 **변수들의 의미를 이해하기 힘들며, 가독성이 낮아 유지보수에 있어서도 매우 비효율적**이다.  

<img width="774" alt="constant2" src="https://user-images.githubusercontent.com/78818063/169978648-e4a626ce-b9c3-4ac3-abf6-924457a1adec.png">

위 같은 문제점을 해결하기 위해 **인터페이스를** 사용하여 위처럼 각 필드를 **관심사에 따라 여러 집합으로 분리**할 수 있다. 각 집합은  
필요한 비즈니스 로직에 맞춰진 객체가 생성되었고, **중복된 변수명이 있어도 문제없이 사용**할 수 있다. 또한 **static final 키워드를  
생략할 수 있어 코드의 가독성도 조금 더 높아졌다**. 하지만 다시 한 가지 문제점 생기는데, 아래처럼 **서로 다른 타입의 상수를 비교하면  
컴파일 시점이 아닌 런타임 시점에 오류가 발생**한다. 즉 예상하지 못한 런타임 에러로 서비스가 중단되는 상황이 발생할 수도 있다.

<img width="777" alt="constant3" src="https://user-images.githubusercontent.com/78818063/169978654-5a9d1784-e547-4a25-a8fc-cb72928e563d.png">

마지막으로 앞서 인터페이스를 사용했던 방식을 **class**로 전환하였다. 그리고 상수의 관심사에 따라 집합을 분류하였으며, 내부  
필드는 **접근 제어자를 public으로 선언해 상수 값들을 유틸 필드처럼 사용**할 수도 있다. 클래스로 집합을 표현하여 이전과 같이  
서로 다른 집합의 타입이 다른 경우 컴파일 시점에서 오류를 확인할 수 있어 곧바로 수정이 가능해졌지만, **switch 문에서 사용하지  
못한다는 한 가지 단점을 지닌다**. 보통 상수 값들은 switch 문과 함께 사용해야 가독성이 좋아져 높은 효율을 발휘할 수 있는데  
해당 조건에 들어가는 데이터 타입은 제한적이기 떄문에 인스턴스를 그대로 넣어 각 상수 값으로 분류할 수 없다. 따라서 이러한  
불편함과 문제점을 개선하여 나온 것이 Enum이다.

<img width="777" alt="constant4" src="https://user-images.githubusercontent.com/78818063/169978656-f04d32ce-c355-43fb-a025-5ab9de6ee6a8.png">

먼저 Enum 타입의 클래스 파일을 만들어 **내부에 열거할 상수들을 선언**한다. 관례적으로 상수는 모두 **대문자를 사용**하여 표현해야  
하며 **여러 단어의 조합은 언더바**를 사용한다. Enum은 다른 클래스와 같이 **참조 타입**이므로 위와 같이 객체를 만들어 값을 사용해야  
한다. Heap에 메모리가 할당되는 인스턴스와는 달리 **Enum은 내부적으로 statck 영역**에 할당되며, **상수가 참조하는 리터럴 값의  
실제 주소를 참조**하고 있다. 위 같은 이유는 **내부에서 선언한 상수에 static과 final 키워드가 기본적으로 생략**되어 있기 때문이다.  
그리고 내부에 여러 함수를 통해 해당 객체와 상수 값을 다룰 수 있다.  

<br>

## 2. Enum의 활용(생성자)과 이점  
<img width="779" alt="constant5" src="https://user-images.githubusercontent.com/78818063/169978661-b7d13fab-bde8-4dc3-aa0a-264fad97f2b1.png">

Enum은 열거할 상수에 **추가적인 속성을 부여**할 수 있는데, 예를 들어 게시글을 작성할 때 제목과 본문의 허용 글자 값을 같이  
표현해야 한다면 위 코드와 같이 속성으로 표현 가능하다. 그리고 생성자를 사용해 **추가적인 속성을 내부의 필드 값으로 정해주고  
별도의 getter 메소드를 만들어 값을 반환받을 수 있다**. 즉 이런식으로 메소드나 필드를 Enum 내부에 추가하여 **상수 데이터를  
더욱 연관시키고 객체의 책임을 분리시킬 수 있다**. 또한 한 가지 특이한 점으로 Enum의 생성자는 접근 제어자를 `private`  
형태로 지닌다. 해당 이유는 앞서 말했듯 **내부 상수들에는 static과 final이 숨겨져 있는데, 이는 즉 고정된 상수 값이란 의미로    
Java의 컴파일러는 해당 변수들의 존재를 런타임이 아닌 컴파일 타임에 알고 있어야 한다**. 즉 **외부에서 동적으로 접근해 해당  
상수들에 영향을 줄 수 없기 때문에 강력한 타입 안정성을 부여**받는다. 즉 Enum을 통해 상수를 관리하면, 상수 집합의 객체의  
인스턴스 생성과 상속을 방지하며 해당 집합을 모두 `싱글톤`으로 관리할 수 있다. 이외에도 Enum이 가지는 이점은 아래와 같다.  

* **단순한 코드와 높은 가독성**
* **인스턴스 생성을 방지하여 타입안정성 보장**
* **컴파일 시 타입 안정성**
* **의도가 열거임을 명확히 표현**

<br>
