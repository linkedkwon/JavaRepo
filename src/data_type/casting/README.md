# 타입 변환 Casting
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Casting-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 형변환(Casting)이란?
  <img width="696" alt="casting" src="https://user-images.githubusercontent.com/78818063/168502606-7e65009b-7553-4e30-b1be-cd2e17340531.png">

  프로그램을 개발하다보면 종종 서로 **다른 타입**을 가진 변수들의 연산이 필요한 경우가 발생한다. 실수를 정수 값으로  
  변환하거나 숫자를 문자로 변환 하는 등의 작업들이 대표적으로 많이 요구되어 진다. Java는 이러한 변수 사이 타입  
  불일치를 해결하기 위해 `형변환`이라는 기능을 제공하는데, 변수(원시, 참조 모두 해당) 또는 리터럴이 가진 타입을  
  **다른 타입으로 변환시키는 작업**을 뜻한다. 위 코드처럼 원시 타입은 실수의 소수점을 버린 정수로, 참조 변수는  
  상속 관계에 있는 부모와 자식 클래스 사이에서 변환이 가능하다.

<br>

## 2. 업 캐스팅(Up Casting, 자동 형변환)
  <img width="688" alt="downCasting" src="https://user-images.githubusercontent.com/78818063/168502611-660c586b-e66f-46c5-a065-71e7c22edf6c.png">

  Java에서 제공되는 상속 관계의 기본적인 특징으로 **자식 클래스는 부모 클래스 모든 특성을 받아 사용**할 수 있다.  
  즉 상속 관계나 특정한 규칙이 **하위에서 상위 오브젝트로 변환되는 과정**을 의미한다. 이론적으로 기존 범위보다  
  더 넓게 형태를 확장시키기 때문에 컴파일러가 데이터의 손실이 없다 판단하여 타입을 **자동으로 변환시킨다**.

<br>

## 3. 다운 캐스팅(Down Casting, 강제 형변환)
  <img width="742" alt="upCasting" src="https://user-images.githubusercontent.com/78818063/168502613-53f4ea14-22ad-4f42-8825-ecd2d4918964.png">

  다운 캐스팅은 업캐스팅과는 반대로 상속 관계의 자식 클래스가 부모 클래스의 객체를 참조하는 것 또는 **오브젝트를 다시  
  원상태로 되돌리는 것을 의미**한다. 업 캐스팅과 반대로 인스턴스의 범위가 더욱 좁아져 자식 요소에 존재하는 필드나  
  메소드에는 접근하지 못하는데 이러한 특성때문에 **정확한 형변환 추리가 불가능하다 판단하므로 반드시 데이터 타입을  
  명시적으로 지정**해줘야 한다. 또한 **업캐스팅이 미리 선언되지 않을 경우 런타임 에러를 발생시킨다**.

<br>

## 4. 형변환이 필요한 이유
  형변환은 객체지향적 관점에서 `추상화`를, 컴파일러 관점에서는 `타입 추론`을 위해 사용되어 진다. 일반적으로 상속을  
  받는 행위는 **동일하지 않은 정보를 하위 클래스에서 다루기 위함**이고 **상위 클래스에서 다루는 정보들은 관계된 인스턴스가  
  모두 공통적으로 다루기 위해 사용**하는 것이 바람직하다. 아래 그림에서 형변환이 어떻게 다형성을 부여하는지 살펴보자.

  <img width="680" alt="abstract" src="https://user-images.githubusercontent.com/78818063/168502614-092a4408-438b-4f60-9995-2a7bde4fb2a4.png">

  자식 클래스는 각기 개별적으로 자신의 특성에 맞는 내부 필드와 메소드를 가지고 있다. 보통 다형성을 활용해 부모 클래스의  
  메소드를 재정의할 수도 있고, 인자 타입에 따라 여러 개의 함수를 추상화할 수도 있다. 위 코드는 클래스에서 공통적으로 사용되는  
  함수의 인자 타입이 각각 구분되는 경우의 예시다. 타입을 구분하기 위해서 첫 번째, 하위 클래스에서 `오버라이딩(Overriding)`으로  
  메소드를 재정의해서 사용할 수 있고, 두 번째로 해당 부모 클래스에서 인자 타입이 다른 함수를 `오버로딩(Overroading)`하여 해결  
  가능하다. 하지만 이러한 두 방식은 비용이 너무 많이 들고, 실행되는 메소드의  내부 로직이 모두 같다면 사용하기 적합하지 않다.  
  따라서 위 경우는 업 캐스팅을 활용해 **인자들의 타입 간의 불일치를 없애주는 것이 바람직하다**. 결론적으로 상위 클래스의 메소드는  
  타입 불일치 문제를 추상화하여 각각의 타입에 다형성을 부여하였으며, 자식 클래스들은 메소드 호출에 있어 비용을 절감하였다.

<br>

