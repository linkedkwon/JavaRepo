# 타입 변환 Casting
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Casting-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 형변환(Casting)이란?
  <img width="696" alt="casting" src="https://user-images.githubusercontent.com/78818063/168502606-7e65009b-7553-4e30-b1be-cd2e17340531.png">

  프로그램을 개발하다보면 종종 서로 **다른 타입**을 가진 변수들의 연산이 필요한 경우가 발생한다. 실수를 
  정수 값으로 변환하거나 숫자를 문자로 변환 하는 작업 등이 이에 해당된다. Java는 이러한 변수 사이 타입 
  불일치를 해결하기 위해 `형변환`이라는 기능을 제공하는데, 변수(원시, 참조 모두 해당) 또는 리터럴이 가진 타입을 
  **다른 타입으로 변환시키는 작업**을 뜻한다. 위 코드처럼 원시 타입은 실수의 소수점을 버린 정수로, 참조 변수는 
  상속 관계에 있는 부모와 자식 클래스 사이에서 변환이 가능하다.

<br>

## 2. 업 캐스팅(Up Casting, 자동 형변환)
  <img width="742" alt="upCasting" src="https://user-images.githubusercontent.com/78818063/168502613-53f4ea14-22ad-4f42-8825-ecd2d4918964.png">

  Java에서 제공되는 상속 관계의 기본적인 특징으로 **자식 클래스는 부모 클래스 모든 특성을 받아 사용**할 수 있다. 
  즉 상속 관계나 특정한 규칙이 **하위에서 상위 오브젝트로 변환되는 과정**으로 보다 상위 타입으로 형변환하는 것을 의미한다. 
  숫자나 객체 모두 기존 범위보다 더 좁은 형태로 축소시키기 때문에 컴파일러가 이미 사용할 값과 필드 범위에 대해 인지할 수 있어 
  타입이 **런타임 중 자동으로 변환된다**.

<br>

## 3. 다운 캐스팅(Down Casting, 강제 형변환)
  <img width="688" alt="downCasting" src="https://user-images.githubusercontent.com/78818063/168502611-660c586b-e66f-46c5-a065-71e7c22edf6c.png">

  다운 캐스팅은 기존 업 캐스팅 된 **객체를 다시 원상태로 되돌리는 것을 의미**한다. 업 캐스팅과 반대로 숫자나 객체의 필드 
  접근 범위가 더 넓어지기 때문에 런타임에 컴파일러가 이를 인지할 방법이 없어, **정확한 형변환 추리가 불가능하다 판단하여 
  선언 시 데이터 타입을 반드시 명시해줘야 한다. 또한 기존 업캐스팅이 선언되어야만 사용 가능하며, **해당 타입이 미리 선언되지 
  않았을 경우에는 런타임 에러를 발생시킨다**.

<br>

## 4. 형변환이 필요한 이유
  형변환은 객체지향적 관점에서 `추상화`를, 컴파일러 관점에서는 `타입 추론`을 위해 사용된다. 일반적으로 상속을 사용하는 이유는 
  클래스들이 공통으로 다루는 정보와 행위를 **상위 클래스에서 다루고 **동일하지 않은 개별적인 정보를 하위 클래스에서 다루기 위함**이다. 
  그렇다면 아래 그림에서 형변환이 상속 관계에서 어떻게 다형성을 부여하는지 알아보자.

  <img width="680" alt="abstract" src="https://user-images.githubusercontent.com/78818063/168502614-092a4408-438b-4f60-9995-2a7bde4fb2a4.png">

  자식 클래스는 각기 개별적으로 자신의 특성에 맞는 내부 필드와 메소드를 가지고 있다. 보통 다형성을 활용해 부모 클래스의 
  메소드를 재정의할 수도 있고, 인자 타입에 따라 여러 개의 함수를 추상화할 수도 있다. 위 코드는 클래스에서 공통적으로 사용되는 
  함수의 인자 타입이 각각 구분되는 경우의 예시다. 타입을 구분하기 위해서 첫 번째, 하위 클래스에서 `오버라이딩(Overriding)`으로 
  메소드를 재정의해서 사용할 수 있고, 두 번째로 해당 부모 클래스에서 인자 타입이 다른 함수를 `오버로딩(Overroading)`하여 해결 
  가능하다. 하지만 이러한 두 방식은 비용이 너무 많이 들고, 실행되는 메소드의 내부 로직이 모두 같다면 사용하기에 적합하지 않다. 
  따라서 위 경우는 업 캐스팅을 활용해 **인자들의 타입 간의 불일치를 없애주는 것이 바람직하다**. 결론적으로 상위 클래스는 공용으로 
  사용할 메소드에서 일어나는 하위클래스들의 타입 불일치 문제를 추상화하여 공통으로 한 곳에서 관리할 수 있으며, 자식 클래스들은 해당 
  메소드를 따로 재정의하지 않아 비용을 절감할 수 있다.

<br>

