# Copy(복사)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Copy-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


## 1. Call By Value or Reference
  애플리케이션을 개발하다 보면 특정 공간에서 사용했던 변수와 인스턴스가 필요한 상황이 자주 발생한다. 보통 변수의 스코프를 전역으로 지정해 직접적으로 참조하는 경우를 
  제외하고는 `Getter & Setter(메소드 호출)`나 `생성자 패턴`과 같은 방식으로 필요한 여러 값들을 **파라미터로 넘겨받을 수 있다**. 그렇다면 특정 메모리 공간에 
  할당된 데이터 값을 어떤 원리로 넘겨주고 있을까? 아래 그림은 자바가 아닌 C 언어에서 사용하는 값을 호출하는 두 가지 방식을 나타낸다.

  <img width="484" alt="callBy2case" src="https://user-images.githubusercontent.com/78818063/166444994-72bffb94-263e-42d2-87e2-f544bf693e59.png">
  
  먼저 두 값의 합을 구하는 메소드는 `값에 의한 호출(Call By Value)` 방식을 사용하는데, 해당 방식은 a와 b에 저장된 리터럴 값 자체를 복사해 파라미터 변수에 값을 
  대입해 넘겨준다. 이는 **변수의 원본 값을 바꾸지 않고 보존하며, 생성된 파라미터에 리터럴 값만 대입하는 방식**이다. 다음은 서로의 값을 변경하는 메소드로 `참조에 의한 
  호출(Call By Reference)` 방식을 사용한다. 이는 이전 방식과 다르게 메소드의 파라미터가 & 연산자를 사용해 변수가 실제로 가르키는 메모리 주소 값을 넘겨준다. 그리고 
  아래 로직에서 파라미터 변수에 복사된 주소값을 통해 실제 메모리에 할당된 기존 변수에 접근해 로직을 처리한다. 즉 **주소값 자체를 복사해서 넘겨주는 방식으로 변수가 할당된 
  메모리에 직접적으로 접근**하는 방식을 의미한다.   
  
  <br>

  위 두 가지 방식은 각각 장단점을 가지고 있는데, 먼저 값에 의한 호출은 복사한 값을 처리하기 떄문에 기존 값을 담고 있는 변수(또는 인스턴스)의 리터럴 값이 보존되어 
  **높은 안정성**을 지닌다. 반면에 방법 그대로 값을 복사했기 때문에 **메모리 사용량이 늘어난다는 단점을 지닌다**. 그리고 참조에 의한 호출은 직접적으로 주소에 참조하기 
  때문에 **빠른 속도**를 지닌다. 하지만 직접적인 참조로 원본 값이 변경되어 생길 수 있는 리스크(Side-Effect)가 있어 **안정성이 떨어지고 보안에 매우 취약**하다.

<br>

## 2. Java는 Call By Value만
  앞서 C 언어에서 값을 호출하는 두 가지 방식을 살펴보았는데, Java에서는 이러한 과정을 어떻게 처리하는지 알아보자.

  <img width="598" alt="callByValueForJava" src="https://user-images.githubusercontent.com/78818063/166450810-fc52a2d7-3067-480c-9790-142250dea8b0.png">

  결론부터 말하자면 **Java는 Call By Value 방식만 채택**해 값을 처리한다. 앞서 설명했던 방식과 같은 원리를 적용해 `기본 자료형은 원본 값을 복사`해 파라미터에 
  대입하여 사용하며, 참조 자료형은 힙 영역에 생성된 인스턴스를 가리키는 `참조 주소 값을 복사`해 새로운 참조 변수를 가진 파라미터를 통해 해당 인스턴스를 다룬다. 위 그림에서 
  값을 변경하는 함수의 파라미터는 각각 기존에 생성했던 인스턴스의 참조 주소와 변수의 리터럴 값을 복사하여 파라미터로 넘겨받고 있다.

<br>

## 3. 얕은 복사(Shallow Copy)
  앞서 우리는 Java의 값에 의한 참조 원리에 대해 이해할 수 있었다. 이러한 복사 방식은 `얕은 복사(Shallow Copy)`라 부르며, 참조 자료형은 **실제 인스턴스를 가리키고 
  있는 주소 값을 복사**한다. 그렇다면 실제 메모리 내부 상황은 어떤지 아래 그림을 살펴보자.  
  
  <img width="727" alt="shallowCopy" src="https://user-images.githubusercontent.com/78818063/166454082-07ff7e7e-79b8-4a3f-b1dd-0742eab16095.png">
  
  인스턴스를 생성했을 때 Heap 영역에 해당 인스턴스의 메모리가 할당되며, Stack에는 해당 인스턴스를 가리키는 주소를 지닌 새로운 참조 변수를 생성한다. 그리고 파라미터 
  또는 새로운 객체에 이전에 생성했던 객체를 대입하면 **기존에 만들었던 인스턴스를 가리키는 새로운 참조 변수가 하나 더 생기게 되는 것이다**. 즉 Stack에 있는 두 객체가 
  참조하고 있는 실제 값은 같으므로 복사한 객체를 통해 원본 값을 다룰 수 있다. 

<br>

## 4. 깊은 복사(Deep Copy)
  다음은 `깊은 복사(Deep Copy)`로 참조 주소 값을 공유하는 방식이 아닌 기본 자료형의 **리터럴 값이나 인스턴스 자체를 새로운 메모리 공간에 복사하는 방법**을 의미한다. 
  인스턴스 값을 복사하는 방법은 세 가지가 있는데 아래에서 코드와 함께 자세히 살펴보자. 

  * ### 복사 생성자와 복사 팩토리 ###
    가장 이상적인 방법으로 `복사 생성자와 팩토리`를 만들어 복사하고자 하는 인스턴스를 넘겨받아 새로운 인스턴스를 생성하는 방식이다.  

    <img width="624" alt="factory" src="https://user-images.githubusercontent.com/78818063/166458767-ccd54c4e-dc71-4fca-9238-1b78c0699518.png">

  * ### 직접 객체 생성 ###
    클래스 내부에 팩토리나 어댑터를 두지 않고 **외부에서 직접 인스턴스의 값을 가져와 인스턴스를 복사**하는 방법이다.  
  
    <img width="629" alt="direct" src="https://user-images.githubusercontent.com/78818063/166458777-d4f19ab0-4ea1-4f3c-97a5-2a9a68ecfb4d.png">

  * ### Clonable 인터페이스 ###
    `Cloneable`은 Java에서 인스턴스의 복사를 지원하는 인터페이스로 `clone()` 메소드를 재정의하여 사용 가능하다. 반드시 반환 값을 `super.clone()` 상위 클래스로 지정해 줘야 하는데, 
    복사한 인스턴스로 같은 메모리 크기를 확보한 뒤 해당 인스턴스의 필드 내용을 복사한다. 이는 **생성자를 호출하는 것이 아니기 때문에 특수한 초기화가 필요한 경우 clone() 메소드 내부에서 특수한 
    로직을 재정의할 수도 있다.** 보통 final로 선언된 상수 인스턴스나 배열을 사용할 때 원**본 값을 안전하게 유지시키기 위해 사용**된다.
    
    <img width="629" alt="cloneable" src="https://user-images.githubusercontent.com/78818063/166458780-1aa37dd9-bddd-42a2-b668-54509ae2fb2e.png">

<br>
