# 일급 컬렉션(First Class Collection)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/CollectionFramework-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/FirstClass-blue"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


## 1. 일급 컬렉션(First Class Collection)이란?
<img width="653" alt="firstClassCollection" src="https://user-images.githubusercontent.com/78818063/169639963-cf1ae130-35ef-45c9-8235-423c67f7888f.png">

`일급 컬렉션`이란 컬렉션을 클래스로 `래핑(Wrapping)`하여 **내부에 해당 객체 외에 어떠한 필드도 두지 않는  
상태의 클래스를 의미**한다. 위 코드는 컬렉션을 래핑하는 가장 기본적인 방법으로 래핑된 클래스는 **컬렉션  
데이터를 보호하고, 여러 작업들을 수행하는 근원지 역할**을 한다. 컬렉션을 데이터 특성에 적합한 그룹으로    
분리하거나 그룹화하여 각 인스턴스의 특성에 맞게 **동작 규칙 또는 필터와 같은 메소드를 포함시킬 수 있다**.  

<br>

## 2. 사용하는 이유
일급 컬렉션은 데이터를 구조화하고 처리하는데 유용한 설계 방식으로 아래와 같은 여러 이점을 가지고 있다.  

  * ### 비즈니스에 종속적인 자료 구조 ###
    <img width="653" alt="forBusiness" src="https://user-images.githubusercontent.com/78818063/169639970-9d13d388-d458-437b-bbe9-77cf297bf4c2.png">

    실제 애플리케이션에서는 **서비스 로직에 따라 특정한 컬렉션 데이터 값이 요구**되는 경우가 빈번하게 발생한다.  
    예를 들어 상품 후기를 작성한 회원에게 포인트를 지급하기 위해, 게시글이 10개 이상인 회원들의 집합이 필요하다.  
    해당 작업을 `쿼리`로 수행하면 시간이 많이 지연 돼 실제 서비스에서 장애가 일어날 수 있으며, `서비스 레이어`에서  
    처리하기엔 회원 클래스가 컴포넌트에 종속되어 버린다. 또한 기능이 많지 않아 회원 데이터를 필터링할 새로운  
    `객체를 만들기`엔 수지타산이 맞지 않다. 이렇게 **비즈니스 로직에 따라 특정한 컬렉션 데이터가 필요한 경우에는    
    인스턴스를 래핑하여 일급 컬렉션으로 만든 후 내부에 작업을 메소드를 두고 필요한 컬렉션 데이터를 반환** 받는다.  
    
  * ### 컬렉션의 상태 유지 ###
    <img width="650" alt="final" src="https://user-images.githubusercontent.com/78818063/169639975-46595562-c3d6-4f90-98f9-64d1db9df98a.png">
    
    실제 서비스에서는 수많은 `Side-Effect`가 발생하기 떄문에 인스턴스를 불변 상태로 유지시켜야 할 때가 많다.  
    일반적으로 Java의 키워드 `final`을 사용하면 원시 타입은 불변 상태로 유지시키는데 반해, **참조 타입은 해당 변수에  
    재참조를 금지시킬 뿐 할당된 인스턴스의 내부 상태는 수정이 가능**하다. 컬렉션 데이터를 수정 또는 삭제없이 유지시켜야  
    한다면 일급 컬렉션을 사용해 클래스 **내부에 별도의 함수를 두지 않고 반환받도록 설계가 가능**하다. **만약 컬렉션의 일부 원소  
    상태가 변화된 인스턴스가 필요하다면 새로운 인스턴스를 만들어(Deep Copy) 원본은 유지한 채로 데이터를 반환**할 수 있다.
    
  * ### 상태와 행위를 한 곳에서 관리 ###
    <img width="654" alt="oneSide" src="https://user-images.githubusercontent.com/78818063/169639976-f3d430d3-6cad-4bca-af57-85d9bb4c3e1a.png">

    컬렉션에서 특정 값을 계산해야 하는 경우에는, 위 코드처럼 컬렉션 데이터를 반환받아 내부를 순환하여 요구되는  
    값을 계산할 것이다. 하지만 여기서 문제점이 하나 발생한다. 위처럼 서비스 컴포넌트와 같은 **외부에서 이러한 작업을  
    수행**한다면 특정 공간에서 컬렉션 데이터 값의 관리와 로직이 함께 존재하게 된다. 이러한 특성의 로직들은 외부의  
    여러 곳에 종속되어 같은 기능을 하는 메소드를 중복 생성할 수 있고 코드가 길어지고 각각의 의미를 알아보기 힘들기  
    떄문에 유지보수 측면에 매우 불리해진다. 이때 일급 컬렉션을 사용하면 **클래스 그 자체로 값과 로직에 대한 모든 작업을  
    함께 진행할 수 있어, 어느 곳에도 종속되지 않아 하나의 오브젝트로 모든 상태와 행위를 관리**할 수 있다.  
    
  * ### 컬렉션 네이밍 ###
    <img width="653" alt="naming" src="https://user-images.githubusercontent.com/78818063/169639978-4ecce9fd-4704-493d-aed0-c902e5f7d069.png">

    **일급 컬렉션을 사용하면 컬렉션에 이름을 붙일 수 있는데**, 회원의 등급을 일반과 프리미엄과 같은 역할(ROLE)로  
    정의해 각 등급에 따라 제공되는 서비스가 다르다고 가정해보자. 이를 구분하는 일반적인 방법은 **변수명을 바꾸는 것**인데  
    변수명만 바꿨을 뿐, **컬렉션을 관리하는 내부 메소드나 필드는 여전히 한 곳에서 사용되고 있다. 그러므로 해당 그룹들이  
    가진 메소드가 무엇인지, 또 어떻게 관리되는지 정확히 알 수 없댜.** 또한 변수명에 불과하기 때문에 명확한 표현과 의미를  
    부여하기 힘들어 조직에서 사용하기엔 적합하지 않다. 일급 컬렉션을 사용하면 위의 코드처럼 분리된 그룹을 **개별로 래핑하여  
    각각의 관심사에 따른 상태와 행위를 관리**할 수 있다. 위 코드는 일반 회원과 프리미엄 회원의 컬렉션을 각각 구분하였고  
    프리미엄 회원에게만 쿠폰을 지급하는 메소드(행위)를 포함시키고 있다.

<br>
