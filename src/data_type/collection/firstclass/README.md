# 일급 컬렉션(First Class Collection)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/CollectionFramework-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/FirstClass-blue"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


## 1. 일급 컬렉션(First Class Collection)이란?
`일급 컬렉션`이란 컬렉션을 클래스로 `래핑(Wrapping)`하여 **내부에 해당 컬렉션 객체를 제외한 어떠한 필드도 두지 않는 상태의 클래스를 의미**한다.
아래 코드는 컬렉션을 래핑하는 가장 기본적인 방법으로 래핑된 클래스는 **컬렉션 데이터를 보호하고, 여러 작업들을 수행하는 근원지 역할**을 한다. 또한 
컬렉션을 데이터 특성에 따라 적합한 그룹화 또는 분리하여 각 특성에 맞게 **동작, 규칙, 필터링 등의 여러 메소드를 포함시킬 수 있다**.  

<img width="653" alt="firstClassCollection" src="https://user-images.githubusercontent.com/78818063/169639963-cf1ae130-35ef-45c9-8235-423c67f7888f.png">


<br>

## 2. 사용하는 이유
일급 컬렉션은 데이터를 구조화하고 처리하는데 유용한 설계 방식으로 아래와 같은 이점들을 지니고 있다.  

  * ### 비즈니스에 종속적인 자료 구조 ###
    실제 애플리케이션에서는 **비즈니스 로직에 따라 특정한 데이터 집합이 요구**되는 경우가 많이 발생한다. 예를 들어 상품 후기를 작성한 회원에게 포인트를 지급하기 위해 10개 이상의
    게시글을 작성한 회원들의 정보가 필요하다. 해당 작업은 `쿼리`로 수행하면 쉽게 처리 가능하다. 하지만 트랜잭션은 기본적으로 작업 수행 비용이 높아 비효율적이고 때에 따라 실시간으로 서비스에
    문제가 발생할 수도 있다. 그렇다면 회원 정보를 모두 받아와 특정 공간에서 작업을 실행해야 하는데, 이는 해당 작업을 실행한 모듈 또는 컴포넌트에 회원 데이터가 종속되는 상황이 발생한다. 그렇다고
    이같은 단발성 작업 때문에 새로운 `객체를 만들기`엔 수지타산에 맞지 않다. 이처럼 **비즈니스 로직에 따라 특정한 데이터 집합이 필요한 경우에는 일급 컬렉션을 사용해 해결 가능하다. 인스턴스를 래핑해
    일급 컬렉션을 만들어 필터링과 같이 내부에 데이터를 가공할 작업 로직을 두면 별도의 비용없이 비즈니스에 종속적인 컬렉션을 가공할 수 있는 것이다.**

    <img width="653" alt="forBusiness" src="https://user-images.githubusercontent.com/78818063/169639970-9d13d388-d458-437b-bbe9-77cf297bf4c2.png">

  * ### 컬렉션의 상태 유지 ###
    실제 서비스에서는 수많은 `Side-Effect`가 발생하기 떄문에 인스턴스를 불변 상태로 유지시켜야 할 때가 많다. 일반적으로 Java의 키워드 `final`을 사용하면 원시 타입을 불변 상태로 유지시키는데 반해,
    **참조 타입은 해당 변수에 재참조를 금지시킬 뿐 할당된 인스턴스의 내부 상태는 수정이 가능**하다. 만약 컬렉션 데이터를 수정 또는 삭제없이 불변 상태로 유지시켜야 한다면 일급 컬렉션을 통해 클래스 **내부에
    별도의 함수를 두지 않고 데이터만 반환받도록 설계가 가능**하다. **만약 컬렉션의 일부 원소 상태를 수정해야 한다면 새로운 인스턴스를 만들어`(Deep Copy)` 원본은 유지한 채로 데이터를 반환**하도록 하자.

    <img width="650" alt="final" src="https://user-images.githubusercontent.com/78818063/169639975-46595562-c3d6-4f90-98f9-64d1db9df98a.png">

  * ### 상태와 행위를 한 곳에서 관리 ###
    컬렉션에서 특정 값을 계산해야 하는 경우에는 아래 코드처럼 컬렉션 데이터를 반환받아 내부를 순환하여 필요한 작업을 수행할 것이다. 여기서 한 가지 문제가 발생할 수 있는데,
    앞서 예로 들었던 것과 같이 이같은 작업을 서비스 컴포넌트와 같은 **외부 공간에서 수행**한다면, 컬렉션 데이터의 관리와 작업 로직이 특정 공간에서 함께 공존하게 된다. 이러한 상황은
    컬렉션 데이터가 점차 외부 여러 곳에 종속되게 만들어 같은 기능을 하는 메소드가 중복 발생되는 현상으로 번져, 길고 복잡해진 코드는 마침내 각각의 의미를 알아보기 힘들어 유지보수
    측면에 매우 불리하게 작용될 수 있다. 이같은 문제 발생은 일급 컬렉션을 사용하면 예방할 수 있다. **클래스 그 자체로 값과 로직에 대한 모든 작업을 미연에 함께 관리시켜, 데이터가 특정
    공간에 종속되는 상황을 막고 하나의 오브젝트로서 모든 상태와 행위를 관리**하는 것이다.  
    
    <img width="654" alt="oneSide" src="https://user-images.githubusercontent.com/78818063/169639976-f3d430d3-6cad-4bca-af57-85d9bb4c3e1a.png">

  * ### 컬렉션 네이밍 ###
    **일급 컬렉션을 사용하면 컬렉션에 이름을 붙여 데이터를 관리할 수 있다.** 특정 서비스에서 회원의 등급을 일반과 프리미엄 두 가지로 나눠 각 등급에 따라 제공되는 서비스가 다르다고 가정해보자.
    이를 구분하기 위한 가장 일반적인 방법은 **서로 다른 변수명을 사용하는 것인데**, 변수명만 바꿨을 뿐 **컬렉션을 다루는 내부 메소드나 필드는 여전히 한 곳에서 관리되기 때문에 실제 로직을 보기
    전까지는 어떤 그룹들이 사용할 메소드인지, 어떤 방식으로 그룹이 관리되는지 정확히 알 수 없다.** 또한 데이터를 나누는 기준이 단순히 변수명에 불과하기 때문에 명확한 표현과 의미를 부여하기는
    힘들고, 문제 발생 소지가 있어 조직에서 사용하기에도 적합하지 않다. 이러한 상황에서 일급 컬렉션을 사용하면 데이터 집합을 보다 명확히 그룹화 할 수 있다. 

    <img width="653" alt="naming" src="https://user-images.githubusercontent.com/78818063/169639978-4ecce9fd-4704-493d-aed0-c902e5f7d069.png">

    아래 코드처럼 일급 컬렉션을 사용해 분리할 그룹을 **개별로 래핑해주면 각각의 관심사에 따른 상태와 행위를 처리**할 수 있고, 앞서 언급했던 여러 장점이 포함된 데이터 집합으로서 관리 가능하다. 위 코드는 일반 회원과 프리미엄 회원의
    컬렉션을 각각 구분해 프리미엄 회원에게만 쿠폰을 지급하는 메소드(행위)를 포함시켜 두 데이터 그룹을 명확히 분리하고 있다.

<br>
