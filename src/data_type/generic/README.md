# 유연한 타입 변환, 제네릭(Generic)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Generic-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


## 1. 제네릭이란?
JDK(Java Development Kit) 1.5 버전부터 지원되는 `제네릭`은 **특정 타입에 의존하지 않고, 하나의 변수가 여러 개의 다른 타입들을 가질 수 있게 
하는 기능을 의미**한다. 인스턴스를 생성하거나 반환할 때 클래스 내부가 아닌 외부에서 사용자가 설정한 파라미터를 통해 타입이 지정된다. 즉 타입을 미리 지정하는 
것이 아니라 필요에 따라 **여러 개의 타입 경계를 지정하고 컴파일 시점에 구체적인 타입을 결정**한다. 정확한 이해를 위해 기존 Object 클래스를 사용하던 
타입 일반화 방식을 먼저 살펴보자.

![generationByObject](https://user-images.githubusercontent.com/78818063/169716697-c69a4775-98eb-456b-9c50-41d480edc853.png)

위 코드는 클래스 필드를 최상위 클래스 **Object 타입**으로 선언해 **외부로부터 업 캐스팅(Up-Casting)된 인스턴스를 주입**받고 있다. 
본래 업 캐스팅은 별다른 문제가 없지만, **다시 외부로 타입을 구체화할 때는 다운 캐스팅(Down-Casting)으로 인해 문제가 발생할 수 있다.** 
따라서 항상 주입받을 필드의 타입을 알맞게 선언하거나 구체화 과정에서 형변환(Casting)할 타입을 정확히 명시해야 하기 때문에 상당히 번거롭게 
느껴질 수 있다. 그렇다면 위 코드에 제네릭 기능을 그대로 적용해보자.

![generic](https://user-images.githubusercontent.com/78818063/169716853-5dd62ea0-cb3e-4005-b22c-7a52e0e48e82.png)

먼저 클래스를 정의할 때 해당 클래스명 뒤에 **<> 괄호와 사용할 키워드**를 붙여줘야 한다. 해당 키워드는 인스턴스를 생성해 필드 값을 초기화할 때 
파라미터로 받을 타입을 의미한다. 그리고 외부에서 인스턴스를 생성할 때도 마찬가지로 클래스명 뒤에 **<> 괄호와 함께 구체적인 타입을 명시해야 한다**. 
이렇게 지정된 타입은 이후 필드 값을 반환받을 때 **컴파일러가 지정한 타입으로 자동으로 바꿔주기 때문에 별도의 형변환 과정없이 타입을 일반화할 수 있다**.

<br>

## 2. 제네릭이 가져다주는 이점
앞서 제네릭 기능을 통해 손쉽게 타입을 일반화 할 수 있었다. 그렇다면 제네릭을 사용했을 때 얻을 수 있는 이점은 무엇이 있을까?

  * ### 자동 형변환 ###
    명시한 타입에 따라 컴파일러는 타입을 자동으로 구성하므로 **강제적인 형변환 과정을 생략해 성능을 향상**시킬 수 있다.  

  * ### 타입 안정성 ###
    런타임이 아닌 **컴파일 시 타입 오류를 체크하므로 사전에 엄격한 타입 검사**가 가능하다.

  * ### 코드 재사용 ###
    **특정 타입에 따른 모든 필드와 메소드를 선언하지 않아** 코드의 재사용성과 유지보수에 용이하다.  

단 제네릭은 컴파일 시점에 타입을 추론해 구체화하기 때문에 **런타임 시점에는 모든 클래스 파일에 제네릭 타입이 소거된다**. 즉 제네릭은 컴파일 시점에 
타입을 추론하는 클래스들과 함께 사용해야만 한다. 예를 들면 배열을 사용했을 때 런타임에 타입이 추론되는 `Array`가 아닌 컴파일 타임에 타입을 추론하는 
`Collection`을 사용해야 하는 것이 바람직하다. 

<br>

## 3. 사용법(How To Use)
제네릭은 Java의 여러 구성 요소들에 적용 가능하며, 여러 사용법들을 포함하고 있다. 자세한 사용법은 다음과 같다. 

  * ### 타입 파라미터 컨벤션 ###
    타입 파라미터 키워드는 정해진 규칙은 없지만 일반적으로 **대문자 알파벳**으로 표현한다. 일반적으로 사용되는 컨벤션은 다음과 같다.
    * **\<T> - Type**
    * **\<E> - Element**
    * **\<K> - Key**
    * **\<N> - Number**
    * **\<V> - Value**
    * **\<R> - Result**
    
  * ### 제네릭 클래스와 메소드 ###
    제네릭 클래스와 인터페이스는 해당 **클래스 명 옆에 제네릭 타입과 키워드를 선언하고, 필드에 타입 키워드를 명시**할 수 있다. 
    그리고 인스턴스를 주입받을 때 **해당 키워드를 재사용하여 유연하게 필드의 타입을 추론**할 수 있다. 
    
    ![genericClassAndMethod](https://user-images.githubusercontent.com/78818063/169716860-68fed7e4-f9ee-423f-a7d7-a0e4f869b3c6.png)

    다음으로 제네릭 메소드는 타입이 메소드 호출 시점에 결정되기 때문에 파라미터 타입에 따라 제네릭 타입이 결정된다. 이러한 타입 결정 
    시점이 달라 **static 키워드와 함께 사용이 가능**하며, **선언부에서 설정한 제네릭으로 메소드의 리턴 타입과 파라미터의 타입을 
    정할 수 있다.** 또한 제네릭 메소드에서 사용되는 타입 인자는 클래스와는 별개 취급하므로 **지역적으로 제네릭 타입을 사용할 때 효율적**이다. 
    보통 특정 상황에 따라 구체적인 타입을 지정하거나 컴파일러가 파라미터 타입으로 반환 타입을 추정하기도 한다.
    
  * ### 멀티 타입 파라미터 ###
    제네릭 타입은 **두 개 이상의 멀티 타입 파라미터**를 사용할 수 있어, 해당 타입을 각각 **콤마**를 사용해 구분한다.

    ![multiParameter](https://user-images.githubusercontent.com/78818063/169716862-67ea45b5-5f5b-4d9a-8e81-7079e5d20243.png)

  * ### 제네릭 와일드 카드 ###
    ![wildcard](https://user-images.githubusercontent.com/78818063/169716865-7eac6f8c-0a02-4b96-8279-a620527a7788.png)
    
    컴파일러는 **대입 연산 시 두 비교 타입이 정확하게 일치하지 않으면 컴파일 에러를 발생**시키지만, 와일드 카드를 사용하면 이 같은 상황에서 
    유연한 대처가 가능하다. 와일드 카드는 데이터의 범위를 지정하는 기능으로 타입 범주에 `물음표(?)` 키워드를 사용해 **추론할 수 있는 타입의 범위**를 
    지정할 수 있다. 총 세 가지 형태로 표현이 가능한데, **기본 <?> 타입은 모든 클래스와 인터페이스 타입**을 대치한다. 그리고 상속 관계를 **extends와 
    super 키워드를 사용해 각각 하위 클래스 또는 상위 클래스의 범주를 지**정할 수 있다.
    
<br>
