# 유연한 타입 변환, 제네릭(Generic)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/DataType-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Generic-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


## 1. 제네릭이란?
JDK(Java Development Kit) 1.5 버전에서 등장한 `제네릭`은 **특정 데이터 타입에 의존하지 않고 하나의 변수가 여러 개의  
다른 타입들을 가질 수 있도록 하는 기능을 의미**한다. 인스턴스를 생성하거나 반환할 때 타입을 클래스 내부에서 지정하지 않고  
**파라미터화**하여 외부에서 사용자에 의해 지정된다. 즉 타입을 미리 지정하는 것이 아닌 필요에 따라 **여러 개의 타입 경계를 지정해    
컴파일 시 구체적인 타입을 결정**한다. 정확한 이해를 위해 기존 Object 클래스를 사용하던 타입 일반화 방식을 아래에서 살펴보자.

![generationByObject](https://user-images.githubusercontent.com/78818063/169716697-c69a4775-98eb-456b-9c50-41d480edc853.png)

위 코드는 클래스 내부 필드를 최상위 클래스 **Object 타입**으로 선언하였으며, 인스턴스를 생성할 때 **외부에서 필드 타입을  
업 캐스팅 (Up-Casting)하여 주입**하고 있다. 이렇게 인스턴스를 생성할 때는 별다른 문제 발생 소지가 없지만, **인스턴스를  
구체화할 때는 다운 캐스팅(Down-Casting)하므로 문제 발생 소지가 생긴다**. 개발자는 매번 정확한 타입을 명시해야 하며  
인스턴스 타입을 구체화하는 모든 과정에서 형변환(Casting)이 이루어지므로 상당히 비효율적인 모습을 보인다. 그렇다면  
위 코드에 제네릭 기능을 그대로 적용해보자.

![generic](https://user-images.githubusercontent.com/78818063/169716853-5dd62ea0-cb3e-4005-b22c-7a52e0e48e82.png)

먼저 클래스를 정의할 때 해당 클래스명 뒤에 **<> 괄호와 사용할 키워드**를 붙여주어야 한다. 해당 키워드는 인스턴스를 생성해  
필드 값을 초기화할 때 파라미터로 받을 타입을 의미한다. 다음으로 외부에서 인스턴스를 생성할 때 마찬가지로 클래스명 뒤에   
**<> 괄호와 함께 구체적인 타입을 명시**한다. 이렇게 명시한 타입은 이후에 인스턴스 필드 값을 반환받을 때 **컴파일러가 지정한  
타입으로 바꿔주기 때문에 별도의 형변환 없이 타입을 일반화할 수 있다**.

<br>

## 2. 제네릭이 가져다주는 이점
앞서 타입 일반화 방식 변화와 제네릭이 무엇인지 살펴 보았는데, 아래에서 제네릭을 사용하면 가질 수 있는 이점을 알아보자.

  * ### 자동 형변환 ###
    명시한 타입에 따라 컴파일러는 타입을 자동으로 구성하므로 **강제적인 형변환 과정이 필요없어 성능을 향상**시킨다.  

  * ### 타입 안정성 ###
    런타임이 아닌 **컴파일 시 타입 오류를 체크하므로 사전에 엄격한 데이터 타입 체크**가 가능하다.

  * ### 코드 재사용 ###
    **특정 타입에 따른 모든 필드와 메소드를 선언하지 않아** 코드의 재사용성과 유지보수에 용이하다.  

단 제네릭은 컴파일 시점에 타입을 추론해 구체화하기 때문에 **런타임 시점에는 모든 클래스 파일에 제네릭 타입이 소거된다**.  
즉 제네릭은 컴파일 시점에 타입을 추론하는 클래스들과 함께 사용해야 한다. 대표적으로 배열을 사용한다면 런타임에 타입이  
추론되는 `Array`가 아닌 컴파일 타임에 타입을 추론하는 `Collection`에 사용하는 것이 바람직하다.  

<br>

## 3. 사용법(How To Use)
제네릭은 Java의 여러 구성 요소들에 적용 가능하며, 여러 사용법들을 포함하고 있다. 아래에서 자세한 사용법을 알아보자.  

  * ### 타입 파라미터 컨벤션 ###
    타입 파라미터 키워드는 정해진 규칙은 없지만 일반적으로 **대문자 알파벳**으로 표현하며, 컨벤션은 아래와 같다.
    * **\<T> - Type**
    * **\<E> - Element**
    * **\<K> - Key**
    * **\<N> - Number**
    * **\<V> - Value**
    * **\<R> - Result**
    
  * ### 제네릭 클래스와 메소드 ###
    ![genericClassAndMethod](https://user-images.githubusercontent.com/78818063/169716860-68fed7e4-f9ee-423f-a7d7-a0e4f869b3c6.png)
    
    먼저 제네릭 클래스와 인터페이스는 해당 **클래스 명 옆에 제네릭 타입과 키워드를 선언하고, 필드에 타입 키워드를 명시하여  
    생성**한다. 그리고 생성자나 메소드를 통해 앞서 사용했던 **키워드를 재사용하여 유연하게 필드의 타입들을 추론**할 수 있다.  
    다음으로 제네릭 메소드는 타입이 메소드 호출 시점에 결정되야 하는 경우 사용되는데, 파라미터 타입에 따라 제네릭 타입이  
    결정된다. 이러한 타입 결정 시점때문에 클래스와 다르게 **static 키워드와 함께 사용이 가능**하며, **선언부에서 제시한 제네릭으로  
    메소드의 리턴 타입과 파라미터의 타입이 정해진다**. 또한 제네릭 메소드에서 사용되는 타입 인자는 클래스와는 별개 취급하므로  
    **지역적으로 제네릭 타입을 사용할 때 효율적**이다. 보통 특정 상황에 따라 구체적인 타입을 지정하거나 컴파일러가 파라미터  
    타입을 통해 반환 타입을 추정하기도 한다.
    
  * ### 멀티 타입 파라미터 ###
    ![multiParameter](https://user-images.githubusercontent.com/78818063/169716862-67ea45b5-5f5b-4d9a-8e81-7079e5d20243.png)
    
    제네릭 타입은 **두 개 이상의 멀티 타입 파라미터**를 사용할 수 있으며, 해당 타입을 각각 **콤마**를 통해 구분한다.
    
  * ### 제네릭 와일드 카드 ###
    ![wildcard](https://user-images.githubusercontent.com/78818063/169716865-7eac6f8c-0a02-4b96-8279-a620527a7788.png)
    
    컴파일러는 **대입 연산 시 두 비교 타입이 정확하게 일치하지 않으면 컴파일 에러를 발생**시키지만, 와일드 카드를 사용하여  
    유연하게 대처가 가능하다. 와일드 카드는 대입할 수 있는 타입의 범위를 지정하는데, 타입 범주에 `물음표(?)` 키워드를  
    사용한다. 총 세 가지 형태로 표현이 가능한데 **기본 <?> 타입은 모든 클래스와 인터페이스 타입**을 대치한다. 그리고 상속  
    관계를 **extends와 super 키워드를 사용해 각각 특정 클래스의 하위 클래스 또는 상위 클래스의 범주를 지**정할 수 있다.
    
<br>
