# 메모리 누수와 예방법
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Memory-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Leak-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


## 1. 메모리 누수(Memory Leak)란?
Java는 개발자가 아닌 JVM(Java Virtual Machine)내부 GC(Garbage Collection)를 통해 메모리를 자동으로 관리한다.  
(자세한 작동 원리는 GC 파트에서 다룬다.) 이때 **더 이상 사용되지 않는 인스턴스들이 GC에 의해 회수되지 않고 누적되는 현상을  
메모리가 누수되었다** 표현한다. 이렇게 회수되지 않은 인스턴스들은 Old 영역에 계속 쌓이게 되는데, 이로 인해 공간이 부족해지면  
Major GC가 계속해서 발생하고 끝내 `OOM(Out Of Memory)` 오류가 발생 돼 애플리케이션이 비정상적으로 종료되기도 한다.  
GC가 되지 않는 루트 참조(Static 키워드 사용, 스택 영역, JNI 객체)를 제외한 Heap 영역의 인스턴스는 참조가 되고 있거나  
참조가 되고 있지 않는 두 가지 상태로 나눌 수 있다. 즉 GC의 회수 대상인 가비지가 되기 위해선 인스턴스를 사용한 뒤에는 반드시   
**참조하는 어떠한 변수도 없도록 해야 한다.** 결론적으로 메모리 누수를 예방하기 위해선 코드를 작성할 때 개발자가 실수하는  
여러 패턴들과 객체들의 특성에 따라 적절한 사용법을 잘 숙지하는 것이 바람직하다.  

<br>

## 2. 메모리 누수를 예방하기
Java의 메모리 자동 관리 지원에도 불구하고 예기치 못하게 캐시나 인스턴스가 지속적으로 참조되고 있어 해제되지 못하는 상황이   
종종 발생한다. 즉 개발자는 사용했던 인스턴스들의 생명주기와 참조 지속성을 잘 파악해 사용해야 하며, 그에 알맞게 코드를 작성해야 한다.  
따라서 아래는 개발자가 자주 실수하는 몇 가지 패턴과 이러한 누수를 예방할 수 있는 몇 가지 기법을 설명하고 있다.  
(Map에서 자동으로 캐시를 삭제하는 WeakHashMap과 더 이상 참조되지 않는 참조의 내용은 이팩티브 자바 저장소에서 다룬다.)

* ### 문자열 연산은 StringBuilder와 StringBuffer 사용하기 ###
  Java는 문자열을 다루는 String 클래스를 제공하는데, 객체에 특정 리터럴 값을 할당하면 해당 변수는 `String Pool`에 적재하여  
  재사용한다. 그외에도 new 연산자를 사용해 인스턴스를 만들면 다른 객체와 마찬가지로 Heap 영역에 적재된다. 따라서 서비스 로직이    
  문자열 연산이 반복된다면 리터럴이나 인스턴스를 무분별하게 생성하지 않고 **가변 상태로 문자를 다루는 Builder나 Buffer를 사용하자**.  
  (자세한 내용은 Data Type > String > Builder에서 다룬다.)
  
* ### 상위 오브젝트 사용, Autoboxing 막기 ###
  <img width="596" alt="autoboxing" src="https://user-images.githubusercontent.com/78818063/165445748-3ee87778-3191-4f04-bb1a-7935503569e4.png">
  
  객체 간 상속 구조나 `래퍼(Wrapper) 클래스`에서 자주 하는 실수로 무분별한 상위 객체를 사용하여 하위 객체가 자동으로 `형변환`되는 상황이  
  발생할 수 있다. 위 예시는 모든 원소의 합을 가리키는 변수를 Wrapper 클래스로 만들어 배열의 원소를 더할 때 마다 각 항목이 무의미하게 형변환된  
  객체를 생성하는 상황을 보여주고 있다. 따라서 기본형 타입(Primitive Type)과 래퍼 클래스 사이 **Autoboxing을 되도록 피하는 것이 좋다**.  

  
* ### Stream을 사용하고 반드시 닫기 ###
  <img width="840" alt="stream" src="https://user-images.githubusercontent.com/78818063/165445734-14d1f6cd-2e6c-44fa-8c9c-3a61d2a5ef83.png">
  
  Input 과 Output, 데이터베이스 연동, 네트워킹과 같이 애플리케이션의 내부에서 외부로 데이터를 전달하기 위한 버퍼 공간을 `스트림(Stream)`이라  
  부른다. 위 그림처럼 스트림을 생성하면 오류로 인한 비정상적인 호출을 제외하고 **연결은 끊기지 않고 계속 지속된다**. 즉 GC가 해당 스트림 인스턴스와  
  내부 데이터들을 여전히 참조 중인 것으로 인지하여 메모리가 누수되는 상황이 발생한다. 따라서 스트림을 사용한 뒤에는 **반드시 close()를 호출해야 한다**.  
  그리고 데이터베이스의 Connection Pool처럼 외부 저장소의 데이터를 담고 있는 인스턴스가 계속 지속되는 경우, 내부적으로 사용했던 Statement나  
  ResultSet과 같은 객체들의 스트림 또한 직접 닫아줘야 한다. 


* ### 캐시 데이터와 메모리 누수 ###
  <img width="679" alt="collection" src="https://user-images.githubusercontent.com/78818063/165445747-e507a644-8a86-4fcb-9e10-d0fa15b71776.png">
  
  `컬렉션 프레임워크(Collection Framework)`에서 제공되는 List, Map, Set 등의 클래스를 사용할 때는 인스턴스의 `캐싱`을 항상 주의해야 한다.  
  컬렉션 클래스에 담겨 있는 해당 **데이터들은 사용 여부를 떠나 GC 대상이 되지 않는다.** 즉 위처럼 특정한 서비스 로직이 끝난 후(다음은 2명의  
  학생의 이름을 받아 출력하는 예시) 컬렉션 인스턴스에 clear() 함수를 사용해 비워주면, 그제서야 인스턴스들은 GC에 의해 가비지 대상이 된다.  


* ### 무분별한 static 키워드 사용 금지 ###
  static 키워드를 붙인 변수는 JVM이 가동될 때 ClassLoader를 통해 Stack 영역에 할당된다. 일반적으로 인스턴스가 생성될 때 마다 Heap 영역에  
  올라가는 것이 아니기 때문에 **빠른 접근 속도와 효율적인 메모리 관리 기능을 제공한다.** 하지만 무분별한 사용은 메모리가 누수되는 주요 원인이 되는데  
  static 변수는 Heap이 아닌 Stack 영역에 할당 돼 **애플리케이션이 종료될 때까지 메모리에 그대로 할당되어 있는다.** 따라서 `공유`되는 값들에만  
  사용하는 것이 좋으며 절대적으로 바뀌지 않는 값에는 `final`과 함께 사용할 것을 권장한다.

  
* ### 커스텀 Key 값(equals() + hashCode()), Key 값은 꼭 불변 ###
  Map은 내부적으로 `해싱`을 통해 키 값을 저장하고 있기 때문에 커스텀 키를 사용하고 싶은 경우에는 `equals()`와 `hashcode()` 메소드 값을  
  기반으로 구현해야 한다. 그렇지 않다면 같은 키 값의 구분이 불가능해져 인스턴스를 인식하지 못하고 Map에 계속 쌓여 점차 메모리를 점유하게 된다.  
  또한 Map에서는 원소의 키 값을 쉽게 변경할 수 있도록 메소드를 제공하는데, 마찬가지로 키 값이 변경되면 해당 인스턴스에 접근할 수 없어 개발자가  
  직접 조작하거나 해당 정보를 찾을 수 없다. 하지만 Map에서는 계속 참조되고 있기 때문에 메모리 누수가 발생한다.  
  
<br>
