# 메모리 누수와 예방법
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Memory-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Leak-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


## 1. 메모리 누수(Memory Leak)란?
Java는 개발자가 아닌 JVM(Java Virtual Machine)의 GC(Garbage Collection)를 통해 메모리를 자동 관리하는데, 
(자세한 작동 원리는 GC 파트에서 다룬다.) 이때 **더 이상 참조되지 않는 인스턴스들이 GC에 의해 회수되지 않고 누적되는 현상을 
메모리가 누수되었다**고 표현한다. 이렇게 회수되지 않은 인스턴스들은 Old 영역에 계속 쌓이게 된다. 이로 인해 공간이 부족해지면 
Major GC가 반복 수행되고, 끝내 `OOM(Out Of Memory)`이 발생되어 애플리케이션이 비정상적으로 종료된다. GC가 수행되지 않는 
루트 참조(Static 키워드 사용, 스택 영역, JNI 객체)를 제외한 Heap 영역의 인스턴스는 참조되고 있거나 참조되지 않는 두 가지 
상태를 갖기 때문에 반드시 인스턴스를 사용한 뒤에는 더 이상 **참조하는 어떠한 변수도 없도록 변수를 잘 관리해야 한다. 또 **메모리 누수를 
예방하기 위해서는 개발자가 실수하는 여러 패턴들과 상황들을 주의하고, 특정 객체들은 사용법을 잘 숙지하는 것이 바람직하다.  

<br>

## 2. 메모리 누수 예방
Java의 메모리 자동 관리 지원에도 불구하고 예기치 못하게 캐시나 인스턴스가 지속적으로 참조되고 있어 할당을 해제하지 못하는 상황이 
종종 발생한다. 즉 개발자는 인스턴스들의 생명주기와 참조 지속성을 잘 파악해야 하며, 그에 알맞게 코드를 작성해야 한다. 아래는 개발자가 
자주 실수하는 몇 가지 패턴과 메모리 누수를 예방할 수 있는 몇 가지 기법을 설명하고 있다.(Map에서 자동으로 캐시를 삭제하는 WeakHashMap과 
더 이상 참조되지 않는 참조의 내용은 이팩티브 자바 저장소에서 다룰 예정이다.)

* ### 문자열은 StringBuilder와 StringBuffer 사용하기 ###
  Java는 문자열을 다루는 String 클래스를 제공한다. 객체에 특정 리터럴 값을 할당하면 해당 값을 `String Pool`에 적재하고 
  재사용한다. 반대로 new 연산자를 통해 인스턴스를 생성하면 다른 객체와 마찬가지로 Heap 영역에 적재되기 때문에 서비스 로직에서 
  문자열 연산이 반복된다면 리터럴이나 인스턴스를 무분별하게 생성하지 않고 **가변 상태로 문자를 다루는 Builder나 Buffer를 사용하는 것이 좋다**. 
  (자세한 내용은 Data Type > String > Builder에서 다룬다.)
  
* ### 상위 오브젝트 사용, Autoboxing 막기 ###
  객체 간 상속 구조나 `래퍼(Wrapper) 클래스`에서 자주 등장하는 실수로 무분별한 상위 객체를 사용하면 하위 객체가 자동으로 `형변환`되는 상황이 
  발생할 수 있다. 아래 예시는 모든 원소의 합을 가리키는 변수를 Wrapper 클래스로 만들어 배열의 원소를 더할 때 마다 각 항목이 무의미하게 형변환된 
  객체를 생성하고 있다. 따라서 타입을 확실히 예측 가능한 경우에는 기본형 타입(Primitive Type)과 래퍼 클래스 사이 **Autoboxing을 되도록 피하는 것이 좋다**. 
  
  <img width="596" alt="autoboxing" src="https://user-images.githubusercontent.com/78818063/165445748-3ee87778-3191-4f04-bb1a-7935503569e4.png">
  
* ### Stream을 사용하고 반드시 닫기 ###
  Input 과 Output, 데이터베이스 연동, 네트워킹과 같이 애플리케이션의 내부에서 외부로 데이터를 전달하기 위한 버퍼 공간을 `스트림(Stream)`이라 
  부른다. 스트림을 생성하면 오류로 인한 비정상적인 호출을 제외하고선 **왠만하면 연결은 끊기지 않고 계속 지속된다**. 즉 GC가 해당 스트림 인스턴스와 
  내부 데이터들을 여전히 참조 중인 것으로 인지하여 메모리가 누수되는 것이다. 따라서 스트림을 사용한 뒤에는 **반드시 close()를 호출해줘야 한다**. 
  그리고 데이터베이스의 Connection Pool처럼 외부 저장소의 데이터를 담고 있는 인스턴스가 계속 지속되는 경우, 내부적으로 사용했던 Statement나 
  ResultSet과 같은 객체들의 스트림 또한 직접 닫아줘야 한다. 

  <img width="840" alt="stream" src="https://user-images.githubusercontent.com/78818063/165445734-14d1f6cd-2e6c-44fa-8c9c-3a61d2a5ef83.png">

* ### 캐시 데이터와 메모리 누수 ###
  `컬렉션 프레임워크(Collection Framework)`에서 제공되는 List, Map, Set 등의 클래스를 사용할 때는 항상 인스턴스의 `캐싱`을 주의해야 한다. 
  컬렉션 클래스에 담겨 있는 **데이터들은 사용 여부를 떠나 GC 대상이 되지 않기 때문인데,** 특정한 서비스 로직이 끝난 후(다음은 2명의 학생의 이름을 받아 
  출력하는 예시) 컬렉션 인스턴스에 clear() 함수를 사용해 비워주면, 그제서야 인스턴스들은 GC에 의해 가비지 대상이 된다. 
  
  <img width="679" alt="collection" src="https://user-images.githubusercontent.com/78818063/165445747-e507a644-8a86-4fcb-9e10-d0fa15b71776.png">

* ### 무분별한 static 키워드 사용 금지 ###
  static 키워드를 붙인 변수는 JVM이 가동될 때 ClassLoader를 통해 바로 Stack 영역에 할당된다. 보통 변수나 인스턴스를 참조하려면 주소가 필요한데, 
  이와 달리 전역에서 공유하기 때문에 **빠른 접근 속도와 효율적인 메모리 관리 기능을 제공한다.** 하지만 무분별한 사용은 메모리가 누수되는 주요 원인이 되는데, 
  이는 **애플리케이션이 종료될 때까지 메모리에 그대로 할당되어 있기 때문이다.** 따라서 반드시 `공유`되는 값에만 사용하는 것이 좋으며, 절대적으로 바뀌지 않는 
  값에는 `final`과 함께 사용해 불변성을 유지시키는 것이 좋다.

* ### 커스텀 Key 값(equals() + hashCode()), Key 값은 꼭 불변 ###
  Map은 내부적으로 `해싱`을 통해 키 값을 저장하고 있기 때문에 커스텀 키를 사용하고 싶은 경우에는 `equals()`와 `hashcode()` 메소드 값을 
  기반으로 구현해야 한다. 그렇지 않다면 같은 키 값의 구분이 불가능해져 인스턴스를 인식하지 못하고 Map에 계속 쌓여 점차 메모리를 점유하게 된다. 
  또한 Map에서는 원소의 키 값을 쉽게 변경할 수 있도록 메소드를 제공하는데, 마찬가지로 키 값이 변경되면 해당 인스턴스에 접근할 수 없어 개발자가 
  직접 조작하거나 해당 정보를 찾을 수 없다. 하지만 Map에서는 계속 참조되고 있기 때문에 메모리 누수가 발생한다. 
  
<br>
