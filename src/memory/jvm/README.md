## JVM(Java Virtual Machine) 구조
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Memory-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/JVM-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


### 1. JVM이란?
JVM은 첫 번째 원칙 `한 번 작성해, 어디에서나 실행 가능함`을 목표로, 자바로 작성된 파일을 운영체제와 상관없이 
독립적으로 실행(`Cross Platform`)할 수 있도록 하는 자바 가상 머신이다. `.java` 파일을 기계어가 
아닌 `.class` 파일(자바 바이트 코드)로 변환해 OS가 이해할 수 있도록 해석한다. 이 같은 호환성을 갖춘 
반면 정적 컴파일 방식보다 속도가 느리다는 단점이 있었는데, 기존 인터프리터 방식에서 `JIT(Just In Time)` 
컴파일러를 추가해 반복되는 명령어를 캐싱하여 현재는 속도 문제까지 보완하였다. 두 번째 `프로그램의 메모리를 
자동으로 관리하고 최적화 시키는 것`의 원칙으로 `GC(Garbage Collection)`와 같은 자동 메모리 관리 
기법을 사용한다. 이 같은 두 원칙은 Java로 개발된 애플리케이션의 배포 작업을 매우 쉽게 만들어주고, JVM의 
구조와 작동 원리를 잘 이해하고 있다면 개발자는 효율적인 메모리 관리와 함께 메모리 누수와 같은 문제를 1차적으로 
예방할 수 있다. 그렇다면 아래 항목에서 Java 파일의 실행 과정을 JVM의 내부 요소들과 함께 다뤄보자.

<img width="680" alt="jvm" src="https://user-images.githubusercontent.com/78818063/158752790-3a8458e1-7ca5-445f-91bf-e0e2e8a38328.png">

### 2. Java Compiler
Java 컴파일러는 .java 파일을 JVM에서 실행할 수 있는 .class 파일(자바 바이트 코드)로 변환한다. 
이때 한 가지 장점은 한 번 컴파일된 바이트 코드는 JVM(또는 인터프리터)이 설치되어 있는 어떠한 환경에서도 
재컴파일 없이 `재사용` 가능하단 점이다.

### 3. Class Loaader
다음으로 Class Loader는 변환된 class 파일들을 찾아 모으고, 사용할 오브젝트를 초기화하여 메모리에 적재시킨다. 
기본적으로 Loading, Linking, Initialization의 세 가지 과정을 진행하며, 요약하자만 다음과 같다.

        - 기본 클래스, 라이브러리, 커스텀 클래스 등으로 구분해 순서대로 메모리에 탑재시킨다.
        - 로드된 클래스들을 검증하고 사용할 수 있도록 준비한 뒤, 사용할 변수들을 메모리를 할당시킨다.


### 4. Runtime Data Area
Runtime Data Area는 OS로부터 할당받는 메모리 영역으로 사용할 구성요소가 실제 탑재되는 공간이다. 
이들은 목적에 따라 아래와 같이 다섯 가지로 구분되어 있다. 

* ### Method Area(메소드 영역) ### 
  JVM이 구동될 때 `단 한 번만 생성되는 영역`으로 모든 스레드가 공유 가능한 메모리 영역이다. JVM의 실행이 `종료되어야 
  해당 메모리를 반환`하며, 인스턴스 생성을 위한 객체 정보(생성자, 멤버 변수, 메소드)와 함께 Constant pool, 상수, 
  static, final 등 명령어 실행에 필요한 `모든 정적 변수`들을 관리한다. 따라서 스레드가 별다른 제약없이 변수를 참조 
  가능하고, 각 변수들의 물리적 메모리 주소를 변환하여 전달한다.

* ### Heap Area(힙 영역) ### 
  주로 객체들이 할당되는 공간으로 인스턴스, 배열, String Pool 등 동적인 데이터를 관리하는 영역이다. 
  GC 주요 대상으로 참조된 인스턴스와 배열이 재참조되지 않으면, 시간에 따라 우선순위를 정해 자동으로 할당을 
  해제한다.(GC 파트에서 자세히 다룸) Tethod Area와 마찬가지로 인스턴스의 공유가 가능하지만 동시성 문제가 
  생길 우려가 있어, synchronized 블록 등의 디펜시브 코드를 작성하는 것이 좋다.
  
* ### Stack Area(스택 영억) ###
  런타임 메모리 영역으로 메소드 호출 시 스레드에 해당되는 각 고유 스택 영역이 생성된다. 해당 영역에는 
  지역 변수, 파라미터, 리턴 값, 임시값 등의 데이터들이 할당된다. 영역이 지정된 블록의 실행이 끝나고 나면 
  할당받은 메모리를 모두 반환한다.

* ### PC Register(레지스터) ###
  스레드가 할당될 때마다 생기는 영역으로, 현재 스레드가 실행되는 주소와 명령을 저장한다. 

* ### Native Method Stacks(네이티브 스택) ###
  자바 외에 다른 언어로 작성된 코드를 실행할 때 필요한 데이터를 할당시키는 영역이다.

<br>

위 내용을 살펴보면 다섯 가지 영역 중 Method Area와 Heap Area는 `모든 스레드가 공유 가능`한 반면 나머지 영역들은 
생성된 각 스레드마다 생성되고 공유되지 않는다. 따라서 공유 영역은 `동시성 문제`를 잘 예방해야 하고, 무분별한 정적 변수들의 사용을 
막아야 한다. 또한 재참조가 적은 인스턴스는 주입을 하는 등 효율적인 메모리 관리 방식을 적용시킬 필요가 있다.


### 5. Execution Engine  
Execution Engine은 메모리에 로드된 바이트 코드들을 가져와 명령을 실행하고 `기계어로 변환`시킨다. 
Java는 기본적으로 `인터프리터(Interpreter)` 방식을 사용했는데, 느린 속도를 보완하기 위해 `JIT(Just In Time)컴파일러`를 
추가하여 현재는 함께 사용하고 있다. 기본적으로 인터프리터 방식을 통해 명령어를 한 줄씩 실행하는데, 이때 
반복되는 코드를 발견하면 JIT컴파일러를 통해 코드를 모두 컴파일하고 기계어로 변환시킨다. 이후 반복 코드가 
발견되면 `캐싱`된 기계어를 직접 사용하기 때문에 시스템 성능을 향상시키고 기존 속도의 단점을 보완한다. 

* ### 인터프리터 vs 컴파일 ###
  인터프리터는 명령어를 한 줄씩 읽고 실행하여 기계어로 변환하는 방식을, 컴파일은 전체 코드를 한 번에 변환하는 방식을 의미한다. 
  전자는 실행 속도가 느린 반면 한 번 컴파일 된 코드의 재컴파일 과정을 생략할 수 있고, 명령어 실행 중 오류가 발생되면 컴파일을 
  멈춰 오류 대처나 코드를 수정하기 편리하다. 반면 후자는 기계어로 변환된 파일을 실행하므로 속도가 매우 빠르지만, 오류가 발생하면 실행 자체가 
  되지 않아 디버깅이 힘들고, 코드를 수정하면 모든 코드를 재컴파일 해야 하는 번거로움을 가진다. 

<br>
