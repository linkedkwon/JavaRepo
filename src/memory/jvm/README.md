## JVM(Java Virtual Machine) 구조
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Memory-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/JVM-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


### 1. JVM이란?
JVM은 첫 번째 원칙 `한 번 작성해, 어디에서나 실행한다`을 기반으로, 자바로 작성된 파일을 운영체제와 상관없이  
독립적으로 실행(`Cross Platform`)할 수 있도록 하는 자바 가상 머신이다. `.java` 파일을 기계어가 아닌 `.class` 파일(자바 바이트 코드)로 변환하여  
OS가 이해할 수 있도록 중간에서 해석한다. 호환성을 갖춘 반면 정적 컴파일 방식보다 속도가 느리다는 단점이 있는데,  
JVM은 기존 인터프리터 방식의 명령어 실행에 `JIT(Just In Time)` 컴파일러를 도입해 반복되는 명령어를 캐싱하여 속도 문제를 보완하였다.   
두 번째는 `프로그램의 메모리를 알아서 관리하고 최적화 시키는 것`의 원칙으로 `GC(Garbage Collection)` 같은 자동 메모리 관리 기법을 사용한다.  
따라서 JVM의 구조와 작동 원리를 알고 있다면 개발자의 코드는 더욱 효율적으로 메모리 관리가 가능하며,  
메모리 누수와 같은 문제를 1차적으로 예방할 수 있는 예방 코드(Defensive Code)를 작성할 수 있어, 필수적으로 이해해야 할 내용이다.

<img width="680" alt="jvm" src="https://user-images.githubusercontent.com/78818063/158752790-3a8458e1-7ca5-445f-91bf-e0e2e8a38328.png">

### 2. Java Compiler
먼저 Java 컴파일러를 통해 .java 파일을 .class 파일(자바 바이트 코드)로 변환한다.  
이제 한 번 컴파일된 바이트 코드는 JVM(또는 인터프리터)가 설치되어 있는 어떤 환경에서도 재컴파일 없이 `재사용` 가능하다.

### 3. Class Loaader
다음으로 ClassLoader는 변환된 class 파일들을 찾아 모으고, 사용할 오브젝트 초기화하여 메모리에 적재한다.  
기본적으로 Loading, Linking, Initialization의 세 가지 과정으로 이루어지는데, 요약하면 다음과 같다.  

        - 기본 클래스, 라이브러리, 커스텀 클래스 등으로 구분하여 각 순서대로 메모리에 로드한다. 
        - 로드된 클래스들을 검증하고 사용할 수 있도록 준비한 뒤 각 변수에 피료한 메모리를 할당시킨다.


### 4. Runtime Data Area
Runtime Data Area는 OS로부터 할당받는 메모리 영역으로 사용할 데이터들이 탑재되는 공간이다.  
각 영역은 목적에 따라 아래와 같이 다섯 가지로 나눠진다.  
<hr>

**(1). Method Area(메소드 영역)**  
* JVM이 구동될 때 기본적으로 `단 하나만 생성되는 영역`으로  모든 Thread가 공유 가능한 메모리 영역으로 JVM의 실행이 `종료되어야 해당 메모리를 반환`한다.
* 인스턴스 생성을 위한 객체 정보들(생성자, 멤버 변수, 메소드)와 함께 Constant pool, 상수, static, final 등의 명령어 실행에 필요한 `모든 정적 변수`들을 관리한다.
* 각 스레드들은 필요에 따라 변수를 참조 가능하며, 각 변수들의 실제 물리 메모리 주소를 변환해 전달한다.

**(2). Heap Area(힙 영역)**  
* 주로 코드 실행을 위한 객체들이 탑재되는 공간으로 인스턴스, 배열, String Pool 등의 동적인 데이터를 관리하는 영역이다.
* GC의 주요 대상으로 참조된 인스턴스와 배열이 재참조되지 않으면, 해당 시간에 따라 우선순위를 정해 자동으로 할당을 해제한다.(GC 파트에서 자세히 다룸)
* Method Area와 마찬가지로 Thread들이 자원 공유가 가능한데, 같은 애플리케이션을 사용하는 Thread 사이 인스턴스를  
  공유하거나 변수를 사용하는 경우 동시 참조 문제가 생길 우려가 있어, synchronized 블록 등의 디펜시브 코드를 작성하는 것이 좋다.
  
**(3). Stack Area(스택 영억)**  
* 런타임 메모리 영역으로 메소드 호출시 스레드에 해당되는 각 고유 스택 영역이 생성된다.
* 생성된 스택 영역에 해당되는 변수들이 탑재되는데 지역 변수, 파라미터, 리턴 값, 임시값 등이 이에 해당된다.   
  모든 명령 실행이 끝나면 할당받은 메모리를 모두 반환한다.

**(4). PC Register(레지스터)**
* Thread가 생성될 때마다 각각 생성되는 영역으로 현재 스레드가 실행되는 주소와 명령을 저장하는 영역이다.

**(5). Native Method Stacks(네이티브 스택)**
* 자바 이외에 다른 언어로 작성된 코드를 실행할 때 필요한 데이터를 적재하기 위해  사용되는 메모리 영역이다.

<hr>
위 내용을 살펴보면 다섯 가지 영역 중 Method Area와 Heap Area는 `모든 Thread가 공유 가능`한 반면 나머지 영역들은 각각의 스레드마다 생성되고 공유되지 않는다.    
이로부터 Thread 간 `동시성 문제`를 잘 예방해야 하며, 무분별한 정적 변수들의 사용은 막고 재참조가 적은 인스턴스들은 주입을 하는 등 효율적인 메모리 관리 방식을 생각해 볼 수 있다.


### 5. Execution Engine  
Execution Engine은 메모리에 로드된 바이트 코드들을 가져와 명령을 실행하고 `기계어로 변환`시키는 역할을 한다.    
Java는 기본적으로 `인터프리터(Interpreter)` 방식을 사용했는데, 느린 속도를 보완하기 위해  
`JIT(Just In Time)컴파일러`를 추가하여 동시 사용한다. 처음에는 인터프리터 방식으로 명령어를 한 줄씩 실행하다    
반복된 코드를 발견하면 JIT컴파일러를 사용해 해당하는 바이트 코드를 모두 컴파일하고 기계어로 변환시킨다.  
이후 반복적인 메소드 호출에 `캐싱`된 기계어를 직접 사용해 시스템 성능을 향상시키고 기존 속도의 단점을 보완한다.  

        인터프리터 vs 컴파일
        인터프리터는 명령어를 한 줄씩 읽고 실행하여 기계어로 변환하는 방식이고 컴파일은 전체 코드를 한 번에 변환하는 방식이다.   
        전자는 속도가 느린 반면 재컴파일하는 과정을 생략할 수 있고 수정과 오류를 처리함에 있어 편리하다.  
        반면 후자는 기계어로 변환된 파일을 실행하므로 속도가 매우 빠르지만, 오류 발생 시 실행 자체가 되지 않고 
        코드를 수정하면 재컴파일 해야 하는 번거로움이 발생한다. 
