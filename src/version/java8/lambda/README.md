# 람다 표현식(Lambda Expression)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Java-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Version-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Java 8-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Lambda-blue"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 함수형 프로그래밍(Functional Programming)
프로그래밍 패러다임은 어떤 방식으로 목표를 처리할지 관점의 차이를 두는 것으로 시작되어 개발자로 부터 새로운 개발 방식과 여러 문제 해결 방법을 
제시한다. 이는 목표를 절차적으로 `어떻게` 처리할지 상태 변경에 초점을 두는 명령형 프로그래밍에 이어 `무엇`을 처리할지 풀어나가는 선언적 프로그래밍으로 
구분되며, 선언적 프로그래밍의 일종으로 `순수 함수(Pure Function)`**로 문제를 나누고, 이를 응용하여 소프트웨어를 구성하는** `함수형 프로그래밍`**이 
등장**하게 된다. 함수형 프로그래밍 사용을 위해서는 `1급 함수(First class citizen, 또는 1급 객체라 불림)`에 대한 이해가 필요하다. 이는 일반적인 변수를 칭하는 
1급 시민의 특징을 함수에서도 적용한 방식으로 아래 세 가지 조건을 만족시켜야 한다.

* **변수에 할당 가능하다.**
* **인자로 전달 가능하다.**
* **반환 값으로 전달 가능하다.**

<br>

즉 이같은 규칙이 함수에도 적용되어 **함수 자체를 일반 변수처럼 취급**할 수 있으며, 런타임 중 동적으로 선언과 구현 로직을 동시에 작성하는 `익명 클래스(Java)`의 
기능까지 포함하고 있다.

<br>

## 2. 함수형 프로그래밍의 세 가지 조건
일급 함수를 전제로 하는 함수형 프로그래밍은 아래 세 가지 조건이 만족되어야 한다. 

  * ### 순수 함수 ###
    `순수 함수`는 외부 데이터에 직접적으로 의존하지 구현 방식을 의미한다. 오직 **입력된 인자로만 내부 로직을 처리**하기 때문에 외부에 있는 다른 변수 뿐만 
    아니라 프로그램의 실행에도 전혀 **부수 효과(Side-Effect)를 주지 않는다**. 즉 전달 인자가 같다면 순수 함수의 결과는 항상 일정한 상태, `참조 투명성(Referential 
    Transparency)`을 유지해야 한다.
  
  * ### 고차 함수(High Order Function) ###
    1급 함수의 특징으로 고차 함수는 인자로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성하여 반환활 수 있어야 한다.

  * ### 익명 함수(Anonymous Function) ###
    익명 함수란 의미 그대로 이름이 없는 함수로 Java의 `익명 클래스`와 같이 별도의 선언없이 **런타임 중 동적으로 선언과 로직을 수행할 수 있는 
    기능을 갖는다**. 이는 **필요에 따라 일시적으로 단 한 번 사용하는 일회용 함수로 재사용되지 않는 불필요한 클래스나 함수 생성으로 인한 용량과 메모리 
    낭비를 줄 일 수 있다.** 

<br>

## 3. Java 8 람다 표현식
Java 내에서는 이같은 함수형 프로그래밍이 적용되는 특정 자료형을 제공하진 않는다. 하지만 Java 8에서 등장한 `람다식`은 추상 메소드를 단 하나만 
포함하는(default나 static 메소드는 관계 없음) `함수형 인터페이스`를 통해 익명 함수를 구현함으로서 앞서 살펴본 함수형 프로그래밍을 가능하게 하였다. 

<img width="871" alt="case1" src="https://user-images.githubusercontent.com/78818063/187847745-d6bf0579-59c3-4f20-b548-55c11df454e2.png">

위 코드는 Java 8이 등장하기 전 익명 클래스(인터페이스)와 내부 메소드를 구현한 방식과 이를 람다식을 적용하여 변형한 방식 두 가지를 나타낸다. 
기존 익명 함수 구현 방식에 람다식을 적용하여 **메소드 구현이 더욱 간결해져 가독성이 높아졌고**, 외부로부터 **의존성을 제거해 데이터를 더욱 안정적**으로 
관리할 수 있게 되었다. 또한 메소드를 제작하는 과정이 생략되어 **개발 생산성까지 향상**시킬 수 있다.

<img width="869" alt="case2" src="https://user-images.githubusercontent.com/78818063/187847750-06f22897-445a-4def-a3ee-4a0307902ed0.png">

람다식은 표현 방식이 간단해 누구나 쉽게 이해할 수 있는데, 위 코드와 같이 기본적으로 세 가지 요소로 구성되어 있다. 가장 먼저 `메소드 시그니처 ()`로 
인자로 받을 입력 값을 명시하고, `람다식 기호 ->`를 통해 메소드의 구현부를 구분한다. 그리고 `구현부`에서 앞서 인자로 선언된 입력 변수를 통해 적절한 로직을 
작성하면 된다.

<img width="870" alt="case3" src="https://user-images.githubusercontent.com/78818063/187847762-49a1e339-53e4-4040-99ad-753888ff056c.png">

이때 **매개 변수 또는 구현부의 실행문이 단 하나만 존재할 경우 각각 메소드의 시그니처와 중괄호를 생략**할 수 있다.

<br> 

이외에도 람다식은 함수형 프로그래밍을 바탕으로 하기 때문에 병렬 프로그래밍이 가능하며, 지연 연산을 통해 성능면에서도 높은 효율을 보인다. 
다만 그렇다고 모든 코드에 람다식을 남용하면 더욱 이해하기 힘든 모호한 코드가 될 수 있고, 익명 함수의 특성상 재사용이 불가능해 프로그램은 
독립적인 모듈로서의 의미를 점차 잃을 수 있다. 따라서 람다식은 반드시 **목적이 분명한** 함수형 인터페이스를 설계할 때만 사용할 것을 권장한다. 

<br>
